# -*- coding: utf-8 -*-
"""
Higher algebra — cyclic subgroups of Z₆
---------------------------------------

We represent subgroup generation as **reachability under “+k”** on Z₆.

Domain:
    D = {"0","1","2","3","4","5"}    # integers mod 6, as strings

Named relations (intensions, over D×D):
    ex:Add1, ex:Add2, ex:Add3    — one-step edges x → x+k (mod 6)
    ex:Gen1, ex:Gen2, ex:Gen3    — generated-by-k reachability (positive-length)

Meta-relations over *relation names* (intensions):
    SubRelOf(P,Q)      — inclusion of relation names (P ⊆ Q)
    leq_strict(P,Q)    — transitive closure of SubRelOf   (no reflex)
    leq(P,Q)           — leq_strict plus reflexivity      (P ⊆ Q, including P=P)

Semantics (implemented by specialized Python code):

  • Addk:
        holds2(Addk, x, y)  ⇔  y = x + k (mod 6).

  • Genk (“generated by k”):
        holds2(Genk, x, y)  ⇔  ∃n ≥ 1  such that
                               y = x + n·k (mod 6),
     i.e. reachability by a **non-empty** path of Addk-edges.
     (Because the graph can contain cycles, (x,x) may also hold.)

  • SubRelOf and leq:
        SubRelOf(Addk, Genk)   for k ∈ {1,2,3}.
        leq_strict is the transitive closure of SubRelOf.
        leq is leq_strict plus reflexive pairs (R,R).

Questions:

  Q1) Enumerate all ⟨x,y⟩ with holds2(Gen2,x,y).
  Q2) Witness relation-names R s.t. holds2(R,"0","3") ∧ leq(R,Gen3).
  Q3) Check ∀R,y: (leq(R,Gen2) ∧ holds2(R,"0",y)) → holds2(Gen2,"0",y).

This module exposes:
    print_model, print_question, run_queries,
    print_answer, print_reason, run_checks, and main().
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, Iterable, List, Set, Tuple
from collections import defaultdict, deque


# -------------------------
# Domain (individuals)
# -------------------------

# We use stringified integers to stay simple.
D: Tuple[str, ...] = tuple(str(i) for i in range(6))  # "0","1","2","3","4","5"


# -------------------------
# Relation names (intensions)
# -------------------------

EX = "ex:"

Add1, Add2, Add3 = EX + "Add1", EX + "Add2", EX + "Add3"
Gen1, Gen2, Gen3 = EX + "Gen1", EX + "Gen2", EX + "Gen3"

Role = str
Pair = Tuple[str, str]

ROLE_NAMES: Set[Role] = {Add1, Add2, Add3, Gen1, Gen2, Gen3}

# SubRelOf edges tying each step-relation to its generated reachability
SUBRELOF_BASE: Dict[Role, Set[Role]] = {
    Add1: {Gen1},
    Add2: {Gen2},
    Add3: {Gen3},
}


# -------------------------
# Small helpers
# -------------------------

def local(name: str) -> str:
    """Strip namespace prefix ex: for nicer printing."""
    return name.split(":", 1)[1] if ":" in name else name


def fmt_pairs(pairs: Iterable[Pair]) -> str:
    seq = sorted(set(pairs))
    if not seq:
        return "∅"
    return "{" + ", ".join(f"⟨{x},{y}⟩" for (x, y) in seq) + "}"


def fmt_set(names: Iterable[str]) -> str:
    s = sorted(set(names))
    if not s:
        return "∅"
    return "{" + ", ".join(local(n) for n in s) + "}"


def _add_mod6(x: int, k: int) -> int:
    return (x + k) % 6


# =====================
#  Specialized closures
# =====================

def closure_subrel_of(subrel: Dict[Role, Set[Role]]) -> Dict[Role, Set[Role]]:
    """
    Transitive closure of SubRelOf over role-names.

    leq_strict(P,Q) holds iff there is a non-empty path:
        P = R0 ⊆ R1 ⊆ ... ⊆ Rn = Q,  n ≥ 1.
    """
    leq_strict: Dict[Role, Set[Role]] = {r: set() for r in ROLE_NAMES}
    for p, qs in subrel.items():
        leq_strict[p].update(qs)

    changed = True
    while changed:
        changed = False
        for p in ROLE_NAMES:
            new: Set[Role] = set()
            for q in leq_strict[p]:
                new.update(leq_strict.get(q, set()))
            if not new.issubset(leq_strict[p]):
                leq_strict[p].update(new)
                changed = True
    return leq_strict


def closure_leq(leq_strict: Dict[Role, Set[Role]]) -> Dict[Role, Set[Role]]:
    """Add reflexive pairs leq(R,R) on top of leq_strict."""
    leq: Dict[Role, Set[Role]] = {}
    for r in ROLE_NAMES:
        leq[r] = set(leq_strict.get(r, set()))
        leq[r].add(r)
    return leq


def _gen_reachability_pairs(k: int) -> Set[Pair]:
    """
    Compute reachability pairs for Addk on Z6 (positive-length paths).

    For each node s, we do a BFS along the single outgoing edge x → x+k (mod 6),
    collecting all reachable nodes (length ≥ 1). Because the graph may contain
    cycles, (s,s) can appear too.
    """
    nodes = list(range(6))
    edges = {x: {(x + k) % 6} for x in nodes}

    reach: Dict[int, Set[int]] = {x: set() for x in nodes}

    for s in nodes:
        seen: Set[int] = set()
        q: deque[int] = deque()
        # one-step neighbours => start of positive-length paths
        for t in edges[s]:
            q.append(t)
            seen.add(t)
            reach[s].add(t)
        # BFS
        while q:
            u = q.popleft()
            for v in edges[u]:
                if v not in seen:
                    seen.add(v)
                    q.append(v)
                    reach[s].add(v)

    return {(str(x), str(y)) for x in nodes for y in reach[x]}


# =====================
#  Model
# =====================

@dataclass
class CyclicZ6Model:
    individuals: Tuple[str, ...]
    role_ext: Dict[Role, Set[Pair]]
    subrel: Dict[Role, Set[Role]]
    leq_strict: Dict[Role, Set[Role]]
    leq: Dict[Role, Set[Role]]


def build_model() -> CyclicZ6Model:
    """Build the model for Z6 with Add1/2/3 and Gen1/2/3."""
    # Base role extensions
    role_ext: Dict[Role, Set[Pair]] = {r: set() for r in ROLE_NAMES}

    # Addk edges: x → x+k (mod 6)
    for x in range(6):
        sx = str(x)
        role_ext[Add1].add((sx, str(_add_mod6(x, 1))))
        role_ext[Add2].add((sx, str(_add_mod6(x, 2))))
        role_ext[Add3].add((sx, str(_add_mod6(x, 3))))

    # Genk = positive-length reachability under Addk
    role_ext[Gen1] = _gen_reachability_pairs(1)
    role_ext[Gen2] = _gen_reachability_pairs(2)
    role_ext[Gen3] = _gen_reachability_pairs(3)

    # SubRelOf & closures on names
    leq_strict = closure_subrel_of(SUBRELOF_BASE)
    leq = closure_leq(leq_strict)

    return CyclicZ6Model(
        individuals=D,
        role_ext=role_ext,
        subrel=SUBRELOF_BASE,
        leq_strict=leq_strict,
        leq=leq,
    )


# =====================
#  Questions Q1–Q3
# =====================

def q1_gen2_pairs(m: CyclicZ6Model) -> List[Pair]:
    """Q1: enumerate all (x,y) with holds2(Gen2,x,y)."""
    return sorted(m.role_ext.get(Gen2, set()))


def q2_witness_relations(m: CyclicZ6Model) -> List[Role]:
    """
    Q2: Witness relation-names R such that:

        holds2(R,"0","3") ∧ leq(R,Gen3)
    """
    res: Set[Role] = set()
    for R in ROLE_NAMES:
        # leq(R,Gen3) means Gen3 is in the leq-closure of R
        if Gen3 in m.leq.get(R, set()) and ("0", "3") in m.role_ext.get(R, set()):
            res.add(R)
    return sorted(res)


def q3_universal_property_gen2(m: CyclicZ6Model) -> bool:
    """
    Q3: Universal property for Gen2 at source "0":

        ∀R,y: (leq(R,Gen2) ∧ holds2(R,"0",y)) → holds2(Gen2,"0",y)
    """
    for R in ROLE_NAMES:
        if Gen2 not in m.leq.get(R, set()):
            continue
        for y in m.individuals:
            if ("0", y) in m.role_ext.get(R, set()) and ("0", y) not in m.role_ext[Gen2]:
                return False
    return True


# =====================
#  Presentation (printing)
# =====================

def print_model(m: CyclicZ6Model) -> None:
    print("Model")
    print("=====")
    print(f"Elements (individuals) D = {list(m.individuals)} (Z₆, written as strings)\n")

    print("Fixed schema (informal)")
    print("------------------------")
    print("• holds2(R,x,y)  — application: ⟨x,y⟩ ∈ ext(R)")
    print("• SubRelOf(P,Q)  — inclusion over relation *names* (intensions)")
    print("• leq_strict(P,Q), leq(P,Q) — induced ⊆* on names (with/without reflex)\n")

    print("Base step-relations (Addk)")
    print("--------------------------")
    add1 = sorted(m.role_ext[Add1])
    add2 = sorted(m.role_ext[Add2])
    add3 = sorted(m.role_ext[Add3])
    print("Add1 =", fmt_pairs(add1))
    print("Add2 =", fmt_pairs(add2))
    print("Add3 =", fmt_pairs(add3), "\n")

    print("Generated reachability relations (Genk)")
    print("--------------------------------------")
    print("Gen1 =", fmt_pairs(m.role_ext[Gen1]))
    print("Gen2 =", fmt_pairs(m.role_ext[Gen2]))
    print("Gen3 =", fmt_pairs(m.role_ext[Gen3]), "\n")

    print("Inclusions over names (SubRelOf)")
    print("--------------------------------")
    for p, qs in SUBRELOF_BASE.items():
        for q in qs:
            print(f"{local(p)} ⊆ {local(q)}")
    print()


def print_question() -> None:
    print("Question")
    print("========")
    print("Q1) List all (x,y) with holds2(Gen2,x,y).")
    print("Q2) ∃R: holds2(R,0,3) ∧ leq(R,Gen3) ? (witness relation-names).")
    print("Q3) ∀R,y: (leq(R,Gen2) ∧ holds2(R,0,y)) → holds2(Gen2,0,y) ?")
    print()


def run_queries(m: CyclicZ6Model):
    gen2_pairs = q1_gen2_pairs(m)
    witnesses = q2_witness_relations(m)
    ok = q3_universal_property_gen2(m)

    return (
        ("Q1", gen2_pairs),
        ("Q2", witnesses),
        ("Q3", ok),
    )


def print_answer(res1, res2, res3) -> None:
    print("Answer")
    print("======")

    tag1, pairs = res1
    tag2, wits = res2
    tag3, ok = res3

    print(f"{tag1}) Gen2 =", fmt_pairs(pairs))
    print(f"{tag2}) Witness relation-names R = " + (fmt_set(wits) if wits else "∅"))
    print(f"{tag3}) Universal statement holds: {'Yes' if ok else 'No'}\n")


def print_reason() -> None:
    print("Reason why")
    print("==========")
    print("• In Z₆, ⟨1⟩ = Z₆, ⟨2⟩ = {0,2,4}, ⟨3⟩ = {0,3}.")
    print("• We encode “generated-by-k” as reachability under Addk steps using BFS.")
    print("• SubRelOf(Addk,Genk) induces leq_strict and leq over relation *names*.")
    print("• Q2 quantifies over relation names R with R ⊆ Gen3.")
    print("• Q3 states that any R below Gen2 cannot add new pairs beyond Gen2 itself.\n")


# -------------------
# Check (harness)
# -------------------

class CheckFailure(AssertionError):
    pass


def check(c: bool, msg: str):
    if not c:
        raise CheckFailure(msg)


def _expected_gen_k_pairs(k: int) -> Set[Pair]:
    """
    Expected reachability pairs for Addk on Z6 (positive-length paths),
    used as a reference oracle for tests.
    """
    nodes = list(range(6))
    edges = {x: {(x + k) % 6} for x in nodes}
    reach: Dict[int, Set[int]] = {x: set() for x in nodes}

    for s in nodes:
        seen: Set[int] = set()
        q: deque[int] = deque()
        for t in edges[s]:
            q.append(t)
            seen.add(t)
            reach[s].add(t)
        while q:
            u = q.popleft()
            for v in edges[u]:
                if v not in seen:
                    seen.add(v)
                    q.append(v)
                    reach[s].add(v)

    return {(str(x), str(y)) for x in nodes for y in reach[x]}


def run_checks(m: CyclicZ6Model) -> List[str]:
    notes: List[str] = []

    # Expected Gen2 & Gen3 from the procedural oracle
    exp_gen2 = _expected_gen_k_pairs(2)
    exp_gen3 = _expected_gen_k_pairs(3)

    # 1) Gen2 enumeration matches expected reachability
    gen2_actual = set(m.role_ext[Gen2])
    check(gen2_actual == exp_gen2, "Gen2 enumeration mismatch.")
    notes.append("PASS 1: Gen2 enumeration is correct.")

    # 2) Gen3 enumeration matches expected reachability
    gen3_actual = set(m.role_ext[Gen3])
    check(gen3_actual == exp_gen3, "Gen3 enumeration mismatch.")
    notes.append("PASS 2: Gen3 enumeration is correct.")

    # 3) Q2 witnesses for (0,3) under Gen3 are {Add3, Gen3}
    wits = set(q2_witness_relations(m))
    check(wits == {Add3, Gen3}, f"Witness set mismatch for (0,3): {wits}")
    notes.append("PASS 3: Witness set for (0,3) under Gen3 is {Add3, Gen3}.")

    # 4) Universal property for Gen2 at source 0
    check(q3_universal_property_gen2(m), "Universal property failed for Gen2.")
    notes.append("PASS 4: Universal property holds for Gen2 at source 0.")

    # 5) Negative: (0,3) is NOT in Gen2 (different parity classes)
    check(("0", "3") not in m.role_ext[Gen2], "Gen2 incorrectly relates 0 to 3.")
    notes.append("PASS 5: Gen2 excludes cross-parity pair (0,3).")

    # 6) Non-membership example for Gen3: (1,0) not reachable (different cosets mod 3)
    check(("1", "0") not in m.role_ext[Gen3], "Gen3 incorrectly relates 1 to 0.")
    notes.append("PASS 6: Gen3 excludes cross-coset pair (1,0).")

    # 7) leq reflexivity on all relation names
    for r in ROLE_NAMES:
        check(r in m.leq.get(r, set()), f"Reflexivity of leq failed for {local(r)}.")
    notes.append("PASS 7: leq reflexivity holds for all relation names.")

    # 8) SubRelOf inclusions are present in leq_strict
    for (step, gen) in [(Add1, Gen1), (Add2, Gen2), (Add3, Gen3)]:
        check(
            gen in m.leq_strict.get(step, set()),
            f"leq_strict {local(step)} ⊆ {local(gen)} failed.",
        )
    notes.append("PASS 8: leq_strict inclusions Addk ⊆ Genk hold.")

    # 9) Deterministic printing (on Gen2’s expected set)
    s1 = fmt_pairs(sorted(exp_gen2))
    s2 = fmt_pairs(sorted(list(exp_gen2)))
    check(s1 == s2, "Pretty-printer determinism failed.")
    notes.append("PASS 9: Pretty printing is deterministic.")

    return notes


# -------------------
# Standalone runner
# -------------------

def main():
    m = build_model()

    print_model(m)
    print_question()
    res1, res2, res3 = run_queries(m)
    print_answer(res1, res2, res3)
    print_reason()

    print("Check (harness)")
    print("===============")
    try:
        for note in run_checks(m):
            print(note)
    except CheckFailure as e:
        print("FAIL:", e)
        raise


if __name__ == "__main__":
    main()

