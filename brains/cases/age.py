#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
age.py
======

Overview
--------
This module is a tiny, self-contained Python reconstruction of a tutorial-style
N3 rule about age. It derives an age-based property `:ageAbove` from a birth
date and three built-ins:

  • time:localTime   — gives “today”
  • math:difference  — computes the time difference in (tropical) years
  • math:greaterThan — compares a numeric age with a duration threshold

Original N3 rule
----------------
We mirror the following N3 rule (simplified for clarity):

  { ?S :ageAbove ?A } <=
  { ?S :birthDay ?B .
    ""  time:localTime ?D .
    (?D ?B) math:difference ?F .
    ?F math:greaterThan ?A .
  } .

Query:

  ?S :ageAbove "P80Y"^^xsd:duration .

Intuitively, a subject ?S is `:ageAbove ?A` if:

  1. ?S has a birth date ?B;
  2. we take today's date ?D;
  3. compute the age ?F in years between ?D and ?B;
  4. and that age is greater than the duration ?A (e.g. "P80Y").


Higher-order look, first-order core
-----------------------------------
We represent each atomic statement as a triple (S, P, O), and we interpret it
via a fixed **second-order looking** predicate:

    Holds₂(P, S, O)

implemented here by the Python function:

    holds2(goal, θ, trace)  # goal is a triple (S, P, O)

where:

  • P is a predicate name (a string like ":ageAbove", "time:localTime",
    "math:difference", "math:greaterThan"),
  • S and O are terms (constants, variables, or structured tuples), and
  • θ is a first-order substitution for variables ?X (strings starting with "?").

We also provide a convenience layer

    holds3(P, S, O, θ, trace)

which simply calls holds2 on the triple (S, P, O), making the predicate name
P itself a first-order argument. This matches the “higher-order look,
first-order core” view: predicate symbols are just data; the only real
semantic work happens in the fixed interpreter `holds2`.

All reasoning is implemented in this file:
  - unification over triples with variables,
  - one rule for :ageAbove,
  - and three built-ins.


What the script prints
----------------------
When run as a script:

    python age.py

it performs the canonical query

  (?S, ":ageAbove", "P80Y")

given the single fact

  (:patH, ":birthDay", "1944-08-21")

and a fixed “today”:

  2025-06-30

It prints three ARC-style sections:

  1. Answer
     • which subject satisfies :ageAbove "P80Y"
     • that subject's approximate numeric age on 2025-06-30

  2. Reason why
     • the textual rule,
     • a short explanation of how it instantiates in this case,
     • and a step-by-step proof trace generated by holds2

  3. Check (harness)
     • at least five independent tests checking:
         - that :ageAbove "P80Y" holds but :ageAbove "P100Y" does not,
         - that ages and durations line up as expected,
         - that built-ins behave correctly,
         - and that unification for the rule head is sound.
"""

from __future__ import annotations

from datetime import date, datetime
from itertools import count
from typing import Dict, Iterable, Iterator, List, Optional, Set, Tuple
import re

Triple = Tuple[object, str, object]
Subst = Dict[str, object]


# ──────────────────────────────────────────────────────────────
# Ground facts
# ──────────────────────────────────────────────────────────────

facts: Set[Triple] = {
    (":patH", ":birthDay", "1944-08-21"),  # ISO date string
}


# ──────────────────────────────────────────────────────────────
# Rule: :ageAbove
# ──────────────────────────────────────────────────────────────

rule_id = "R-ageAbove"

# Head: ?S :ageAbove ?A
rule_head: Triple = ("?S", ":ageAbove", "?A")

# Body (list of triples):
#   ?S :birthDay ?B .
#   "" time:localTime ?D .
#   (?D ?B) math:difference ?F .
#   ?F math:greaterThan ?A .
rule_body: List[Triple] = [
    ("?S", ":birthDay", "?B"),
    ("", "time:localTime", "?D"),
    (("?D", "?B"), "math:difference", "?F"),  # subject is a pair (D,B)
    ("?F", "math:greaterThan", "?A"),
]


# ──────────────────────────────────────────────────────────────
# Utility: parse dates & durations
# ──────────────────────────────────────────────────────────────

def parse_iso_date(s: str) -> date:
    return datetime.strptime(s, "%Y-%m-%d").date()


_duration_pat = re.compile(r"^P(\d+)Y$")


def duration_to_years(dur: str) -> float:
    """Example: 'P80Y' -> 80.0 (only integer years are supported)."""
    m = _duration_pat.fullmatch(dur)
    if not m:
        raise ValueError(f"Unsupported duration literal {dur!r} (use 'PnY')")
    return float(m.group(1))


# ──────────────────────────────────────────────────────────────
# Unification helpers
# ──────────────────────────────────────────────────────────────

def is_var(t: object) -> bool:
    """Variables are strings starting with '?'."""
    return isinstance(t, str) and t.startswith("?")


def unify(pattern, datum, theta: Optional[Subst] = None) -> Optional[Subst]:
    """
    Tuplewise unification; variables are allowed on the *pattern* side.

    This is enough for our use here, since we always call it with:
      - pattern = something that may contain ?X variables,
      - datum   = a ground or partially grounded triple/term.
    """
    θ: Subst = dict(theta or {})

    # Tuple vs non-tuple
    if isinstance(pattern, tuple) != isinstance(datum, tuple):
        return None

    # Non-tuple: atom or variable
    if not isinstance(pattern, tuple):
        if is_var(pattern):
            if pattern in θ and θ[pattern] != datum:
                return None
            θ[pattern] = datum
            return θ
        return θ if pattern == datum else None

    # Both tuples
    if len(pattern) != len(datum):  # type: ignore[arg-type]
        return None

    for p, d in zip(pattern, datum):  # type: ignore[arg-type]
        θ = unify(p, d, θ)
        if θ is None:
            return None
    return θ


def subst(term, θ: Subst):
    """Apply θ to a term (recursively for tuples)."""
    if isinstance(term, tuple):
        return tuple(subst(x, θ) for x in term)
    return θ.get(term, term)


def subst_triple(trp: Triple, θ: Subst) -> Triple:
    return tuple(subst(t, θ) for t in trp)  # type: ignore[return-value]


# ──────────────────────────────────────────────────────────────
# Built-ins
# ──────────────────────────────────────────────────────────────

def builtin_time_localTime(s, o, θ: Subst) -> Optional[Subst]:
    """'' time:localTime ?D — binds ?D to the fixed 'today' (2025-06-30)."""
    if s != "":
        return None
    today = date(2025, 6, 30)  # fixed “today” for reproducibility
    val = today.isoformat()
    θ2: Subst = dict(θ)
    if is_var(o):
        θ2[o] = val
        return θ2
    return θ2 if o == val else None


def builtin_math_difference(pair, o, θ: Subst) -> Optional[Subst]:
    """(?D ?B) math:difference ?F — years between dates D and B (tropical years)."""
    if not isinstance(pair, tuple) or len(pair) != 2:
        return None
    d_str, b_str = pair
    d_val = parse_iso_date(d_str)
    b_val = parse_iso_date(b_str)
    years = (d_val - b_val).days / 365.2425  # tropical year length
    θ2: Subst = dict(θ)
    if is_var(o):
        θ2[o] = years
        return θ2
    return θ2 if o == years else None


def builtin_math_greaterThan(s, o, θ: Subst) -> Optional[Subst]:
    """
    ?F math:greaterThan ?A where ?A is either a duration 'PnY' or a number.

    Interpreted extensionally as: numeric(s) > numeric(o).
    """
    if isinstance(o, str):
        o_val = duration_to_years(o)
    else:
        o_val = o
    if isinstance(s, (int, float)) and s > o_val:
        return θ
    return None


# ──────────────────────────────────────────────────────────────
# Backward-chaining Holds₂ over triples (trace-collecting)
# ──────────────────────────────────────────────────────────────

def holds2(
    goal: Triple,
    θ: Subst,
    depth: int,
    seen: Set[Triple],
    stepctr: Iterator[int],
    trace: List[str],
) -> Iterable[Subst]:
    """
    Backward-chaining proof search for a single triple goal.

    Conceptually, this is our implementation of the second-order-looking
    predicate

        Holds₂(P, S, O)

    where `goal` is the triple (S, P, O). It:

      • handles built-ins when P is time:localTime, math:difference,
        or math:greaterThan;
      • matches ground facts;
      • and applies the single rule for :ageAbove.
    """
    g = subst_triple(goal, θ)
    trace.append(" " * depth + f"Step {next(stepctr):02}: prove {g}")
    subj, pred, obj = g

    # Built-ins (by predicate)
    if pred == "time:localTime":
        θ2 = builtin_time_localTime(subj, obj, θ)
        if θ2 is not None:
            trace.append(" " * depth + f"✓ built-in time:localTime → {θ2.get(obj, obj)}")
            yield θ2
        else:
            trace.append(" " * depth + "✗ built-in time:localTime failed")
        return

    if pred == "math:difference":
        θ2 = builtin_math_difference(subj, obj, θ)
        if θ2 is not None:
            val = θ2.get(obj, obj)
            val_s = f"{val:.2f}y" if isinstance(val, (int, float)) else str(val)
            trace.append(" " * depth + f"✓ built-in math:difference → {val_s}")
            yield θ2
        else:
            trace.append(" " * depth + "✗ built-in math:difference failed")
        return

    if pred == "math:greaterThan":
        θ2 = builtin_math_greaterThan(subj, obj, θ)
        if θ2 is not None:
            rhs = f"{duration_to_years(obj):.0f}y" if isinstance(obj, str) else obj
            trace.append(" " * depth + f"✓ built-in greaterThan: {subj} > {rhs}")
            yield θ2
        else:
            trace.append(" " * depth + f"✗ built-in greaterThan failed: {subj} ≤ {obj}")
        return

    # Ground facts
    for fact in sorted(facts):
        θ2 = unify(g, fact, {})
        if θ2 is not None:
            trace.append(" " * depth + f"✓ fact {fact}")
            yield {**θ, **θ2}
            return

    # Apply the rule if the head matches
    θ_head = unify(rule_head, g, {})
    if θ_head is None:
        return

    head_inst = subst_triple(rule_head, θ_head)
    if head_inst in seen:  # simple loop guard (not really needed here)
        return

    trace.append(" " * depth + f"→ via {rule_id}")
    θ_curr: Subst = {**θ, **θ_head}

    def prove_body(i: int, θ_now: Subst) -> Iterable[Subst]:
        if i == len(rule_body):
            yield θ_now
        else:
            for θ_next in holds2(
                rule_body[i],
                θ_now,
                depth + 1,
                seen | {head_inst},
                stepctr,
                trace,
            ):
                yield from prove_body(i + 1, θ_next)

    yield from prove_body(0, θ_curr)


def holds3(
    pred: str,
    subj: object,
    obj: object,
    θ: Subst,
    depth: int,
    seen: Set[Triple],
    stepctr: Iterator[int],
    trace: List[str],
) -> Iterable[Subst]:
    """
    Convenience layer:

        holds3("ageAbove", S, A, θ, ...) = holds2((S, ":ageAbove", A), θ, ...)

    It makes the predicate name an explicit first-order argument. This is not
    used by the main script, but it mirrors the Holds₃ view often used in the
    "higher-order look, first-order core" explanations.
    """
    return holds2((subj, pred, obj), θ, depth, seen, stepctr, trace)


def solve(query: Triple) -> Tuple[bool, Subst, List[str]]:
    """Return (success?, substitution, trace) for a single triple query."""
    trace: List[str] = []
    θ = next(holds2(query, {}, 0, frozenset(), count(1), trace), None)
    return (θ is not None), (θ or {}), trace


# ──────────────────────────────────────────────────────────────
# ARC: Answer / Reason / Check
# ──────────────────────────────────────────────────────────────

def arc_answer() -> None:
    """Print the canonical query answer."""
    query: Triple = ("?S", ":ageAbove", "P80Y")
    success, θ, _ = solve(query)

    print("Answer")
    print("------")

    if success:
        s = θ["?S"]
        # Recompute a numeric age (for display only)
        birth = next(
            o for (_, p, o) in facts if p == ":birthDay" and isinstance(o, str)
        )
        years = (date(2025, 6, 30) - parse_iso_date(birth)).days / 365.2425
        print(f"Derived: {s} :ageAbove 'P80Y'^^xsd:duration")
        print(f"Numeric age (as of 2025-06-30): ~{years:.2f} years")
    else:
        print("No derivation for :ageAbove 'P80Y'.")
    print()


def arc_reason(max_lines: int = 40) -> None:
    """Print a short explanation and the proof trace."""
    query: Triple = ("?S", ":ageAbove", "P80Y")
    success, θ, trace = solve(query)

    print("Reason why")
    print("----------")

    print("We use the rule:")
    print("{ ?S :ageAbove ?A } <=")
    print("{ ?S :birthDay ?B .")
    print("  \"\" time:localTime ?D .")
    print("  (?D ?B) math:difference ?F .")
    print("  ?F math:greaterThan ?A .")
    print("} .")
    print()
    print("Instantiations here (for :patH and 2025-06-30):")
    print(" • ?S  = :patH")
    print(" • ?B  = '1944-08-21'")
    print(" • ?D  = '2025-06-30' (via time:localTime)")
    print(" • ?F  ≈ 80.86 (years from 1944-08-21 to 2025-06-30)")
    print(" • ?A  = 'P80Y' ⇒ threshold is 80 years")
    print(" • 80.86 > 80 ⇒ rule head fires, so :patH :ageAbove 'P80Y'")
    print()

    print("Proof trace:")
    for line in trace[:max_lines]:
        print(line)
    if len(trace) > max_lines:
        print(f"… {len(trace) - max_lines} more step(s) …")
    print()


# ──────────────────────────────────────────────────────────────
# Check (harness) — at least five independent tests
# ──────────────────────────────────────────────────────────────

class CheckFailure(AssertionError):
    pass


def check(cond: bool, msg: str) -> None:
    if not cond:
        raise CheckFailure(msg)


def run_checks() -> List[str]:
    """
    Run several independent tests to sanity-check the tiny engine:

      1) :ageAbove P80Y succeeds for :patH.
      2) :ageAbove P100Y fails.
      3) :ageAbove P79Y succeeds (strictly below the true age).
      4) math:difference gives a plausible age in (80, 81) years.
      5) math:greaterThan behaves correctly around the P80Y threshold.
      6) Unification for the rule head works as expected.
    """
    notes: List[str] = []

    # 1) P80Y succeeds
    ok80, θ80, _ = solve(("?S", ":ageAbove", "P80Y"))
    check(ok80 and θ80.get("?S") == ":patH", "Expected :patH to satisfy :ageAbove P80Y.")
    notes.append("PASS 1: :patH satisfies :ageAbove 'P80Y'^^xsd:duration.")

    # 2) P100Y fails
    ok100, _, _ = solve(("?S", ":ageAbove", "P100Y"))
    check(not ok100, "Unexpected success for :ageAbove P100Y.")
    notes.append("PASS 2: No subject satisfies :ageAbove 'P100Y'^^xsd:duration.")

    # 3) P79Y succeeds (since age ≈ 80.86 years)
    ok79, θ79, _ = solve(("?S", ":ageAbove", "P79Y"))
    check(ok79 and θ79.get("?S") == ":patH", "Expected :patH to satisfy :ageAbove P79Y.")
    notes.append("PASS 3: :patH also satisfies :ageAbove 'P79Y'^^xsd:duration.")

    # 4) math:difference sanity: age is between 80 and 81 years
    θ_diff = builtin_math_difference(("2025-06-30", "1944-08-21"), "?F", {})
    check(θ_diff is not None, "math:difference should succeed for valid dates.")
    age_years = θ_diff["?F"]
    check(isinstance(age_years, float), "math:difference result should be a float.")
    check(80.0 < age_years < 81.0, f"Age should be in (80, 81) years, got {age_years:.6f}.")
    notes.append("PASS 4: math:difference returns an age between 80 and 81 years.")

    # 5) math:greaterThan around P80Y threshold
    # Use the numeric age from the previous step.
    check(
        builtin_math_greaterThan(age_years, "P80Y", {}) is not None,
        "Age should be greater than 'P80Y'.",
    )
    check(
        builtin_math_greaterThan(age_years, "P81Y", {}) is None,
        "Age should NOT be greater than 'P81Y'.",
    )
    notes.append("PASS 5: math:greaterThan behaves correctly around 'P80Y'/'P81Y'.")

    # 6) Unification on the rule head
    θ_unif = unify(rule_head, (":patH", ":ageAbove", "P80Y"), {})
    check(θ_unif is not None, "Rule head should unify with (:patH :ageAbove P80Y).")
    check(θ_unif.get("?S") == ":patH" and θ_unif.get("?A") == "P80Y",
          f"Unexpected bindings from head unification: {θ_unif}.")
    notes.append("PASS 6: rule head unification yields ?S=:patH and ?A='P80Y'.")

    return notes


def arc_check() -> None:
    print("Check (harness)")
    print("---------------")
    try:
        for note in run_checks():
            print(note)
    except CheckFailure as e:
        print("FAIL:", e)
        raise
    else:
        print("All checks passed.")
    print()


# ──────────────────────────────────────────────────────────────
# Main
# ──────────────────────────────────────────────────────────────

def main() -> None:
    arc_answer()
    arc_reason()
    arc_check()


if __name__ == "__main__":
    main()

