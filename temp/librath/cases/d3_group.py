#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
D3 (Dihedral group of the triangle) — ARC-ified

We model each symmetry as a permutation of vertex labels 0,1,2.
Composition p∘q means “apply q first, then p”, implemented as tuple(p[q[i]] for i in 0..2).

ARC sections:
- Answer      : Cayley table (row ∘ column) and a demo showing where each symmetry sends the vertices
- Reason why  : quick explanation of generators/relations and how our compose() works
- Check       : harness verifying group axioms and the classic dihedral relations
"""

# ─────────────────────────────────────────────────────────────
# 1) Permutation utilities
# ─────────────────────────────────────────────────────────────

def compose(p, q):
    """
    Composition p∘q for permutations encoded as tuples:
      p, q are length-3 tuples where, e.g., q[i] is the image of i under q.
      (p∘q)[i] = p[q[i]]
    We return a tuple of length 3.
    """
    return tuple(p[i] for i in q)

def inverse(p):
    """Return inverse permutation p^{-1} so that p∘p^{-1} = p^{-1}∘p = identity."""
    inv = [None]*len(p)
    for i, img in enumerate(p):
        inv[img] = i
    return tuple(inv)

# ─────────────────────────────────────────────────────────────
# 2) D3 elements (6 symmetries of an equilateral triangle)
# ─────────────────────────────────────────────────────────────
# Vertex labels: 0, 1, 2 (counter-clockwise)
rot0 = (0, 1, 2)     # e   : identity
rot1 = (1, 2, 0)     # r   : 120° rotation
rot2 = (2, 0, 1)     # r²  : 240° rotation

ref0 = (0, 2, 1)     # s   : reflection across axis through vertex 0
ref1 = (2, 1, 0)     # sr  : reflection across axis through vertex 1
ref2 = (1, 0, 2)     # sr² : reflection across axis through vertex 2

elements = {
    "e"   : rot0,
    "r"   : rot1,
    "r²"  : rot2,
    "s"   : ref0,
    "sr"  : ref1,
    "sr²" : ref2,
}
# choose a nice display order (generators first)
labels = ["e", "r", "r²", "s", "sr", "sr²"]

# quick lookup from permutation to name
perm_to_name = {v: k for k, v in elements.items()}

# ─────────────────────────────────────────────────────────────
# 3) Cayley table (row ∘ column)
# ─────────────────────────────────────────────────────────────
def cayley_table():
    table = {a: {b: None for b in labels} for a in labels}
    for a in labels:
        for b in labels:
            prod = compose(elements[a], elements[b])   # a ∘ b
            table[a][b] = perm_to_name[prod]
    return table

def print_table(table):
    w = max(len(l) for l in labels)
    print("Cayley table for D3 (row ∘ column):")
    header = " " * (w+1) + " ".join(label.rjust(w) for label in labels)
    print(header)
    for row in labels:
        line = row.rjust(w) + " " + " ".join(table[row][col].rjust(w) for col in labels)
        print(line)

# ─────────────────────────────────────────────────────────────
# 4) Demo: where each symmetry sends the triangle’s vertices
# ─────────────────────────────────────────────────────────────
triangle = [(0.0, 0.0), (1.0, 0.0), (0.5, 0.866)]  # coordinates for vertices 0,1,2

def apply(sym, pts):
    """Return new list of points according to the permutation `sym`."""
    return [pts[i] for i in sym]

def demo_positions():
    rows = []
    for name in labels:
        rows.append((name, apply(elements[name], triangle)))
    return rows

# ─────────────────────────────────────────────────────────────
# 5) ARC: Reason why
# ─────────────────────────────────────────────────────────────
def reason_text():
    lines = []
    lines.append("D3 is generated by r (120° rotation) and s (a reflection) with relations:")
    lines.append("  r³ = e,  s² = e,  s r s = r⁻¹.")
    lines.append("We encode symmetries as permutations of vertex indices (0,1,2).")
    lines.append("Our compose(p,q) implements (p∘q)[i] = p[q[i]], i.e., apply q then p.")
    lines.append("The Cayley table lists row ∘ column using that composition rule.")
    return "\n".join(lines)

# ─────────────────────────────────────────────────────────────
# 6) ARC: Check (harness) — verify axioms and dihedral relations
# ─────────────────────────────────────────────────────────────
def check_harness():
    # closure: every product remains one of our 6 elements
    for a in labels:
        for b in labels:
            prod = compose(elements[a], elements[b])
            assert prod in perm_to_name, f"Closure fails for {a}∘{b}"

    # identity: 'e' acts as identity
    e = elements["e"]
    for a in labels:
        assert compose(elements[a], e) == elements[a]
        assert compose(e, elements[a]) == elements[a]

    # inverses: each has a two-sided inverse among the 6
    for a in labels:
        inv = inverse(elements[a])
        name_inv = perm_to_name.get(inv)
        assert name_inv is not None, f"No inverse for {a}"
        assert compose(elements[a], inv) == e
        assert compose(inv, elements[a]) == e

    # associativity: (a∘b)∘c == a∘(b∘c) for all a,b,c
    for a in labels:
        for b in labels:
            for c in labels:
                left  = compose(compose(elements[a], elements[b]), elements[c])
                right = compose(elements[a], compose(elements[b], elements[c]))
                assert left == right, f"Associativity fails for {a},{b},{c}"

    # dihedral relations
    r  = elements["r"]
    r2 = elements["r²"]
    s  = elements["s"]
    # r^3 = e
    assert compose(r, compose(r, r)) == e
    # s^2 = e
    assert compose(s, s) == e
    # s r s = r^{-1} = r²
    assert compose(s, compose(r, s)) == r2

    # composition with reflections behaves as expected:
    # sr  = s∘r, sr² = s∘r² in our naming
    assert elements["sr"]  == compose(s, r)
    assert elements["sr²"] == compose(s, r2)

# ─────────────────────────────────────────────────────────────
# 7) ARC sections
# ─────────────────────────────────────────────────────────────
def main():
    # Build outputs
    table = cayley_table()
    demo  = demo_positions()

    # ----- Answer -----
    print("Answer")
    print("------")
    print_table(table)
    print("\nExample: where each symmetry sends the triangle’s vertices [0,1,2] → coordinates:")
    for name, pts in demo:
        print(f"{name:>3}: {pts}")
    print()

    # ----- Reason why -----
    print("Reason why")
    print("----------")
    print(reason_text())
    print()

    # ----- Check (harness) -----
    print("Check (harness)")
    print("---------------")
    try:
        check_harness()
        print("OK: closure, identity, inverses, associativity, and dihedral relations all verified.")
    except AssertionError as e:
        print("FAILED:", e)
        raise

if __name__ == "__main__":
    main()

