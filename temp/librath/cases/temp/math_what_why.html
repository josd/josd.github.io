<!DOCTYPE html>
<html lang='en'>
<head>
  <meta charset='utf-8' />
  <meta name='viewport' content='width=device-width, initial-scale=1' />
  <title>Mathematics — WHAT & WHY • P3 Demo (one-column, robust)</title>
  <style>
    :root{ --bg:#ffffff; --ink:#111827; --muted:#6b7280; --accent:#2563eb; --ok:#16a34a; --warn:#d97706; --bad:#dc2626; --border:#e5e7eb; --surface:#f8fafc; }
    html,body{ margin:0; padding:0; background:var(--bg); color:var(--ink); font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Inter,sans-serif; }
    .wrap{ max-width:900px; margin:28px auto 80px; padding:0 18px; }
    h1{ font-size:28px; margin:0 0 6px; }
    p.lead{ color:var(--muted); margin:6px 0 18px; }
    .section{ background:#fff; border:1px solid var(--border); border-radius:14px; padding:16px; box-shadow:0 6px 20px rgba(0,0,0,.06); margin:14px 0; }
    label{ display:block; margin:10px 0 4px; color:var(--muted); font-size:13px; }
    input[type='number'], select{ width:100%; background:#fff; color:var(--ink); border:1px solid var(--border); border-radius:10px; padding:10px; }
    .row{ display:flex; gap:12px; flex-wrap:wrap; }
    .col{ flex:1 1 220px; }
    .btn{ background:var(--accent); color:#fff; border:0; padding:10px 14px; border-radius:10px; font-weight:600; cursor:pointer; transition:opacity .15s ease, filter .15s ease; }
    .btn:disabled, .btn.busy{ opacity:.6; cursor:not-allowed; filter:grayscale(1) brightness(.95); }
    .btn.busy::after{ content:''; width:14px; height:14px; border:2px solid rgba(255,255,255,.6); border-top-color:#fff; border-radius:50%; display:inline-block; margin-left:8px; vertical-align:-2px; animation:spin .9s linear infinite; }
    @keyframes spin{ to{ transform:rotate(360deg) } }
    .kpi{ display:flex; gap:12px; flex-wrap:wrap; margin-top:10px; }
    .kpi .item{ background:var(--surface); border:1px solid var(--border); border-radius:10px; padding:8px 10px; min-width:160px; }
    .kpi b{ display:block; font-size:18px; margin-bottom:2px; color:#111; }
    pre{ background:var(--surface); color:#111827; border:1px solid var(--border); border-radius:12px; padding:12px; white-space:pre-wrap; overflow-wrap:anywhere; word-break:break-word; max-height:50vh; overflow:auto; }
    details{ border:1px solid var(--border); border-radius:12px; padding:10px 12px; background:#fff; }
    summary{ cursor:pointer; font-weight:700; }
    .ok{ color:var(--ok) } .warn{ color:var(--warn) } .bad{ color:var(--bad) }
    .log{ font-size:12px; color:var(--muted); margin-top:6px; }
    .prose p{ margin:8px 0; } .prose ul{ margin:8px 0 8px 1.1rem; } .prose li{ margin:4px 0; }
    .muted{ color:var(--muted); }
  </style>
</head>
<body>
  <div class='wrap'>
    <header class='section'>
      <h1>Mathematics — the WHAT & the WHY • P3 Demo</h1>
      <p class='lead'>Answer -> Reason -> Check. We adopt axioms (the library) and see which mathematical concepts and purposes emerge (the path), then verify. Everything runs in your browser.</p>
      <div class='prose'>
        <p><strong>What this is.</strong> A tiny, self-contained demo that tells two stories about mathematics: the <em>WHAT</em> (which ideas appear when we adopt certain axioms) and the <em>WHY</em> (what those ideas are for: invariants, transfer, explanation). It follows the P3 pattern: <em>Answer → Reason → Check</em>.</p>
        <p><strong>How it works.</strong></p>
        <ul>
          <li><b>Library (axioms).</b> A small set of axioms you can think of as dials we may turn on.</li>
          <li><b>Path.</b> A sequence of “adopt AXIOM” steps. As we adopt axioms, concepts become available by dependency (e.g., fields → reals → analysis).</li>
          <li><b>Goal.</b> A target list of observations (both WHAT and WHY items) that we want to see emerge.</li>
          <li><b>Search.</b> We enumerate candidate paths with BFS up to a depth limit. <em>Thorough</em> explores orderings and continues after success; <em>Fast</em> dedupes by state and stops once a success appears.</li>
          <li><b>Top‑down choice.</b> From all consistent endpoints, we pick the shortest path (ties broken deterministically by action strings).</li>
          <li><b>Checks.</b> Independent validations: recompute closure; confirm observations; monotone growth; minimality of axioms and steps; acyclic dependencies; and permutation‑invariance spot checks.</li>
        </ul>
        <p><strong>How to use.</strong> Pick a mode, adjust <em>Max Depth</em> and <em>Cap Paths</em>, set a few <em>Permutation Trials</em>, then click <em>Run</em>. The <em>Status</em> panel shows how much was searched; the three boxes below show the selected answer, the reasoning narrative, and the checks.</p>
        <p><strong>What to expect.</strong> You’ll typically see arithmetic and algebra unlock analysis and geometry, while the WHY track highlights invariants and transfer principles that make results portable across domains. Exact paths can differ with settings.</p>
        <p><strong>What this is not.</strong> Not a proof assistant or a canonical foundation; dependencies are illustrative. Edit the code to reflect your own view of mathematics.</p>
        <p class='muted'><em>Determinism.</em> Ties are resolved lexicographically on the action strings, so repeated runs with the same settings select the same path.</p>
      </div>
    </header>

    <section class='section' id='controls'>
      <h2>Controls</h2>
      <div class='row'>
        <div class='col'>
          <label for='mode'>Mode</label>
          <select id='mode'>
            <option value='thorough' selected>Thorough (order-distinct, expand after success, all axioms)</option>
            <option value='fast'>Fast (dedupe by state, stop after success, only needed axioms)</option>
          </select>
        </div>
        <div class='col'>
          <label for='maxDepth'>Max Depth</label>
          <input id='maxDepth' type='number' min='0' max='20' value='8' />
        </div>
        <div class='col'>
          <label for='capPaths'>Cap Paths</label>
          <input id='capPaths' type='number' min='1000' step='1000' value='120000' />
        </div>
        <div class='col'>
          <label for='permTrials'>Permutation Trials (in Check)</label>
          <input id='permTrials' type='number' min='0' max='10' value='1' />
        </div>
      </div>
      <div class='row' style='align-items:flex-end; margin-top:8px'>
        <button id='runBtn' class='btn'>Run</button>
        <span id='note' class='warn' style='margin-left:8px'></span>
      </div>
      <div class='kpi'>
        <div class='item'><b id='kEnumerated'>-</b><span>Enumerated nodes</span></div>
        <div class='item'><b id='kConsistent'>-</b><span>Consistent endpoints</span></div>
        <div class='item'><b id='kTime'>-</b><span>Total time (ms)</span></div>
        <div class='item'><b id='kMode'>-</b><span>Mode</span></div>
      </div>
      <details style='margin-top:12px'>
        <summary>Show axioms, concepts, observations</summary>
        <div id='dataDump' style='margin-top:10px'></div>
      </details>
      <div id='log' class='log'></div>
    </section>

    <section class='section'>
      <h2>Answer</h2>
      <pre id='answer'></pre>
    </section>

    <section class='section'>
      <h2>Reason</h2>
      <pre id='reason'></pre>
    </section>

    <section class='section'>
      <h2>Check</h2>
      <pre id='check'></pre>
    </section>
  </div>

<script>
window.addEventListener('DOMContentLoaded', function(){
  const logEl = document.getElementById('log');
  const log = (m) => { try { console.log(m); if(logEl){ logEl.textContent = String(m); } } catch(e){} };
  window.addEventListener('error', function(ev){
     const n = document.getElementById('note'); if(n){ n.textContent = 'Script error: ' + ev.message; n.className='bad'; }
     log('Error: ' + ev.message);
  });

  try{
    // Data (Math WHAT & WHY)
    const AX = [
      'classical-logic',
      'set-existence',
      'function-formation',
      'natural-induction',
      'algebra-operations',
      'order-completeness',
      'topology-axioms',
      'symmetry-axioms'
    ];

    const PR = {
      // Foundations
      'proofs': new Set(['classical-logic']),
      'sets': new Set(['set-existence']),
      'functions': new Set(['sets', 'function-formation']),

      // Arithmetic & algebra
      'naturals': new Set(['sets', 'natural-induction']),
      'arithmetic': new Set(['naturals']),
      'rings': new Set(['sets', 'algebra-operations']),
      'fields': new Set(['rings']),

      // Analysis & geometry
      'reals': new Set(['fields', 'order-completeness']),
      'topology': new Set(['sets', 'topology-axioms']),
      'analysis': new Set(['reals', 'proofs']),
      'geometry': new Set(['reals', 'symmetry-axioms']),
      'calculus': new Set(['analysis']),

      // Higher viewpoints
      'category-theory': new Set(['functions', 'proofs']),
      'invariants': new Set(['proofs', 'groups', 'topology']),

      // Algebraic structures
      'groups': new Set(['sets', 'symmetry-axioms']),

      // WHY targets
      'transfer-principle': new Set(['category-theory', 'proofs']),
      'explanatory-power': new Set(['invariants', 'transfer-principle'])
    };

    const OBS = new Set([
      // WHAT
      'arithmetic', 'topology', 'geometry', 'calculus', 'category-theory',
      // WHY
      'invariants', 'transfer-principle', 'explanatory-power'
    ]);

    // Helpers
    const cloneSet = s => new Set(s);
    const union = (a,b)=>{ const r=new Set(a); for(const x of b) r.add(x); return r; };
    const subset = (small, big)=>{ for(const x of small) if(!big.has(x)) return false; return true; };
    const toKey = s => Array.from(s).sort().join('|');
    const shuffle = arr => { for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } };

    function inferConcepts(axioms){
      if(!inferConcepts.cache) inferConcepts.cache = new Map();
      const k = toKey(axioms);
      if(inferConcepts.cache.has(k)) return new Set(inferConcepts.cache.get(k));
      const concepts = new Set();
      let changed = true;
      while(changed){
        changed = false;
        for(const [c, reqs] of Object.entries(PR)){
          if(!concepts.has(c)){
            const unionSet = union(axioms, concepts);
            if(subset(reqs, unionSet)){
              concepts.add(c);
              changed = true;
            }
          }
        }
      }
      inferConcepts.cache.set(k, new Set(concepts));
      return new Set(concepts);
    }

    function neededAxioms(){
      const need = new Set(); const stack = Array.from(OBS); const seen = new Set();
      while(stack.length){
        const x = stack.pop();
        if(seen.has(x)) continue; seen.add(x);
        const reqs = PR[x]; if(!reqs) continue;
        for(const r of reqs){
          if(PR[r]) stack.push(r); else need.add(r);
        }
      }
      return need;
    }

    function expand(ax, allowed){
      const nxt=[]; const sorted = Array.from(allowed).sort();
      for(const a of sorted){ if(!ax.has(a)){ const ns = cloneSet(ax); ns.add(a); nxt.push([a, ns]); } }
      return nxt;
    }

    function enumeratePaths(opts){
      const maxDepth = opts.maxDepth, capPaths = opts.capPaths, thorough = opts.thorough;
      inferConcepts.cache = new Map();
      const useAll = thorough ? true : false;
      const needed = neededAxioms();
      const allowed = useAll ? new Set(AX) : (needed.size ? needed : new Set(AX));
      const dedupe = thorough ? null : new Set([toKey(new Set())]);
      const stopAfterSuccess = thorough ? false : true;
      const initial = [new Set(), []]; // [axioms, steps]
      const queue = [initial];
      const paths = []; let enumerated = 0;

      while(queue.length){
        const [axSet, steps] = queue.shift();
        const conc = inferConcepts(axSet);
        enumerated++;
        paths.push({ path: steps, final_axioms: new Set(axSet), final_concepts: conc });
        const success = subset(OBS, conc);
        if(stopAfterSuccess && success) continue;
        if(steps.length >= maxDepth) continue;
        for(const [ax, newSet] of expand(axSet, allowed)){
          const newConc = inferConcepts(newSet);
          const delta = Array.from(newConc).filter(c => !conc.has(c)).sort();
          const newStep = { action: 'adopt ' + ax, added_axiom: ax, enabled_concepts: delta };
          const child = [newSet, steps.concat([newStep])];
          if(dedupe){ const k = toKey(newSet); if(dedupe.has(k)) continue; dedupe.add(k); }
          queue.push(child);
        }
        if(paths.length >= capPaths) break;
      }
      return { paths: paths, enumerated: enumerated };
    }

    function filterConsistent(paths){ return paths.filter(p => subset(OBS, p.final_concepts)); }
    function choosePath(cands){
      if(!cands.length) return null;
      return cands.sort(function(a,b){
        const len = a.path.length - b.path.length;
        if(len !== 0) return len;
        const aa = a.path.map(s=>s.action).join('||');
        const bb = b.path.map(s=>s.action).join('||');
        return aa.localeCompare(bb);
      })[0];
    }

    function explain(chosen, totalNodes, consistentCount, maxDepth){
      const lines=[];
      lines.push('Goal: demonstrate the WHAT and the WHY of mathematics.');
      lines.push('Target observations: ' + Array.from(OBS).sort().join(', ') + '.');
      lines.push('Enumerated ' + totalNodes + ' candidate states/paths (depth <= ' + maxDepth + ').');
      lines.push('Top-down selection filtered these to ' + consistentCount + ' consistent endpoints.');
      lines.push('We chose the shortest path achieving the goal; ties broken lexicographically.');
      lines.push('Selected steps:');
      for(var i=0;i<chosen.path.length;i++){
        var st = chosen.path[i];
        lines.push('  ' + (i+1) + '. ' + st.action + ' -> newly enabled concepts: ' + (st.enabled_concepts.length ? st.enabled_concepts.join(', ') : '-'));
      }
      lines.push('Final axioms: ' + Array.from(chosen.final_axioms).sort().join(', ') + '.');
      lines.push('Final concepts: ' + Array.from(chosen.final_concepts).sort().join(', ') + '.');
      return lines.join('\n');
    }

    function check(chosen, permTrials){
      const recomputed = inferConcepts(chosen.final_axioms);
      const c1 = toKey(recomputed) === toKey(chosen.final_concepts);
      const c2 = subset(OBS, recomputed);

      let axProg = new Set(); let prevConcepts = new Set();
      let monotonic = true; let enabledOK = true; let seen = new Set();
      for(const st of chosen.path){
        if(!st.added_axiom || seen.has(st.added_axiom)){ monotonic = false; break; }
        seen.add(st.added_axiom);
        axProg.add(st.added_axiom);
        const now = inferConcepts(axProg);
        for(const x of prevConcepts){ if(!now.has(x)){ monotonic = false; break; } }
        const delta = Array.from(now).filter(x=>!prevConcepts.has(x)).sort();
        if(delta.join('|') !== st.enabled_concepts.join('|')) enabledOK = false;
        prevConcepts = now;
      }

      const disp = [];
      for(const ax of chosen.final_axioms){
        const alt = new Set(chosen.final_axioms); alt.delete(ax);
        if(subset(OBS, inferConcepts(alt))) disp.push(ax);
      }
      const minimalAxioms = disp.length === 0;

      let shorter = [];
      if(chosen.path.length>0){
        const res = enumeratePaths({maxDepth: chosen.path.length-1, capPaths: 200000, thorough: true});
        const consShort = filterConsistent(res.paths);
        if(consShort.length){ shorter = consShort[0].path.map(s=>s.action); }
      }
      const minimalSteps = shorter.length === 0;

      function hasCycle(){
        const graph = {}; Object.keys(PR).forEach(k=>graph[k]=new Set());
        for(const [c, reqs] of Object.entries(PR)){ for(const r of reqs){ if(PR[r]) graph[c].add(r); } }
        const visited = new Set(); const stack = new Set();
        function dfs(u){ visited.add(u); stack.add(u);
          for(const v of graph[u]){
            if(!visited.has(v) && dfs(v)) return true;
            if(stack.has(v)) return true;
          }
          stack.delete(u); return false;
        }
        for(const node of Object.keys(graph)){ if(!visited.has(node) && dfs(node)) return true; }
        return false;
      }
      const acyclic = !hasCycle();

      const baseAxioms = toKey(chosen.final_axioms); const baseLen = chosen.path.length;
      let mismatches=[];
      for(let i=0;i<permTrials;i++){
        const perm = AX.slice(); shuffle(perm); if(perm.join('|')===AX.join('|')) shuffle(perm);
        const saved = AX.slice(); AX.length=0; perm.forEach(x=>AX.push(x));
        const res2 = enumeratePaths({maxDepth: 8, capPaths: 120000, thorough: true});
        const cons2 = filterConsistent(res2.paths);
        AX.length=0; saved.forEach(x=>AX.push(x));
        if(!cons2.length){ mismatches.push({trial:i+1, issue:'no_path_under_permutation'}); }
        else{
          const ch2 = choosePath(cons2);
          const eqA = baseAxioms === toKey(ch2.final_axioms);
          const eqL = baseLen === ch2.path.length;
          if(!(eqA && eqL)) mismatches.push({trial:i+1, final_axioms_equal:eqA, path_length_equal:eqL});
        }
      }
      const permInv = mismatches.length===0;

      const passed = c1 && c2 && monotonic && enabledOK && minimalAxioms && minimalSteps && acyclic && permInv;
      return {
        recomputed_concepts_match: c1,
        observations_satisfied: c2,
        monotonic_along_path: monotonic,
        enabled_records_consistent: enabledOK,
        axiom_minimality: minimalAxioms,
        dispensable_axioms: disp.sort(),
        minimal_steps: minimalSteps,
        shorter_path_example: shorter,
        acyclic_concept_dependencies: acyclic,
        permutation_invariant: permInv,
        permutation_mismatches: mismatches,
        passed: passed
      };
    }

    // UI wiring
    const el = {
      mode:document.getElementById('mode'),
      maxDepth:document.getElementById('maxDepth'),
      capPaths:document.getElementById('capPaths'),
      permTrials:document.getElementById('permTrials'),
      runBtn:document.getElementById('runBtn'),
      answer:document.getElementById('answer'),
      reason:document.getElementById('reason'),
      check:document.getElementById('check'),
      kEnumerated:document.getElementById('kEnumerated'),
      kConsistent:document.getElementById('kConsistent'),
      kTime:document.getElementById('kTime'),
      kMode:document.getElementById('kMode'),
      note:document.getElementById('note'),
      dataDump:document.getElementById('dataDump')
    };
    if(!el.runBtn){ log('Run button not found'); return; }

    function dumpData(){
      const axs = '<b>Axioms</b><br>' + AX.map(a=>'- '+a).join('<br>');
      const obs = '<br><b>Target observations</b><br>' + Array.from(OBS).map(o=>'- '+o).join('<br>');
      const deps = '<br><b>Concept dependencies</b><br>' + Object.entries(PR).map(([k,v])=>' - <code>'+k+'</code> <- ' + Array.from(v).join(', ')).join('<br>');
      el.dataDump.innerHTML = axs+obs+deps;
    }
    dumpData();

    el.runBtn.addEventListener('click', ()=>{
      el.runBtn.disabled = true; el.runBtn.classList.add('busy'); el.runBtn.dataset.prev = el.runBtn.textContent; el.runBtn.textContent = 'Running...';
      el.note.textContent = ''; el.note.className='warn';
      el.answer.textContent = el.reason.textContent = el.check.textContent = '';
      el.kEnumerated.textContent = '...'; el.kConsistent.textContent='...'; el.kTime.textContent='...'; el.kMode.textContent = el.mode.value;

      const thorough = el.mode.value === 'thorough';
      const maxDepth = parseInt(el.maxDepth.value,10)||8;
      const capPaths = parseInt(el.capPaths.value,10)||120000;
      const permTrials = parseInt(el.permTrials.value,10)||1;

      const finish = () => { el.runBtn.classList.remove('busy'); el.runBtn.textContent = el.runBtn.dataset.prev || 'Run'; el.runBtn.disabled = false; };

      requestAnimationFrame(()=>{
        try{
          const t0 = performance.now();
          const res = enumeratePaths({maxDepth:maxDepth, capPaths:capPaths, thorough:thorough});
          const consistent = filterConsistent(res.paths);
          const chosen = choosePath(consistent);
          const t1 = performance.now();

          el.kEnumerated.textContent = res.enumerated.toLocaleString();
          el.kConsistent.textContent = consistent.length.toLocaleString();
          el.kTime.textContent = Math.round(t1 - t0).toLocaleString();

          if(!chosen){
            el.answer.textContent = JSON.stringify({selected_path:null, final_state:null}, null, 2);
            el.reason.textContent = 'No consistent path found under current depth and logic.';
            el.check.textContent = JSON.stringify({passed:false}, null, 2);
            el.note.textContent = 'Tip: Thorough mode often needs Depth 8 and Cap Paths >= 120,000 here.';
            finish(); return;
          }

          const answer = {
            selected_path: chosen.path.map(s=>s.action),
            final_state: {
              axioms: Array.from(chosen.final_axioms).sort(),
              concepts: Array.from(chosen.final_concepts).sort()
            }
          };
          el.answer.textContent = JSON.stringify(answer, null, 2);
          el.reason.textContent = explain(chosen, res.enumerated, consistent.length, maxDepth);

          const chk = check(chosen, permTrials);
          el.check.textContent = JSON.stringify(chk, null, 2);

          el.note.textContent = chk.passed ? 'All checks passed.' : 'Some checks failed. See details above.';
          el.note.className = chk.passed ? 'ok' : 'bad';
        } catch(err){
          el.note.textContent = 'Runtime error: ' + err.message;
          el.note.className = 'bad';
          log(err && err.stack ? err.stack : err);
        } finally {
          finish();
        }
      });
    });

    log('Ready.');
  } catch(e){
    log('Init error: ' + e.message);
    const n = document.getElementById('note'); if(n){ n.textContent='Init error: ' + e.message; n.className='bad'; }
  }
});
</script>
</body>
</html>
