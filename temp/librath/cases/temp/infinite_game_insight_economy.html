<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>The Infite Game of the Insight Economy — P3 Triad Demo</title>
<style>
  :root{
    --bg:#ffffff; --ink:#1e2430; --muted:#5d6b82; --panel:#f7f9fc; --border:#e3e8f1;
    --green:#0a7f3f; --red:#c62828; --blue:#1f6feb; --amber:#b26a00;
    --pillbg:#eef2f8;
  }
  html,body{background:var(--bg); color:var(--ink); font:16px/1.55 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Helvetica,Arial,sans-serif; margin:0;padding:0}
  .wrap{max-width:1000px; margin:28px auto; padding:0 16px}
  h1{font-size:1.7rem; margin:.4rem 0 1rem}
  h2{font-size:1.3rem; margin:1.2rem 0 .6rem; color:var(--blue)}
  h3{font-size:1.05rem; margin:1rem 0 .4rem; color:var(--muted)}
  p{margin:.5rem 0}
  .panel{background:var(--panel); border:1px solid var(--border); border-radius:12px; padding:14px 16px; margin:12px 0}
  .muted{color:var(--muted)}
  .pill{display:inline-flex; align-items:center; gap:.35rem; padding:2px 10px; border-radius:999px; background:var(--pillbg); color:var(--muted); border:1px solid var(--border); font-size:.9rem}
  .pill.pass{color:var(--green); border-color:#bfe6cf; background:#e9f7ef}
  .pill.fail{color:var(--red); border-color:#f5c2c7; background:#fdecee}
  .pill.info{color:var(--blue); border-color:#c7dcff; background:#eef4ff}
  .scoreboard table{width:100%; border-collapse:collapse; font-variant-numeric:tabular-nums}
  .scoreboard th,.scoreboard td{padding:10px 8px; border-bottom:1px solid var(--border); vertical-align:top}
  .scoreboard th{text-align:left; color:var(--muted); font-weight:600; letter-spacing:.02em}
  pre{white-space:pre-wrap; background:#f1f4fa; padding:10px 12px; border-radius:10px; border:1px solid var(--border); overflow:auto; font-size:.9rem}
  .checks .row{display:flex; align-items:flex-start; gap:10px; padding:8px 0; border-bottom:1px dashed var(--border)}
  .checks .code{min-width:54px; text-align:center; font-weight:700; color:var(--blue)}
  .checks .msg{flex:1}
  .checks .status{min-width:76px; text-align:center}
  .tag{background:#eef2f8; border:1px solid var(--border); color:#334155; padding:2px 8px; border-radius:8px; font-size:.82rem; display:inline-block; margin:2px 4px 0 0}
  .summary{display:flex; gap:12px; flex-wrap:wrap; margin-top:10px}
  .summary .box{background:#f1f4fa; padding:10px 12px; border-radius:10px; border:1px solid var(--border)}
  a.help{color:var(--blue); text-decoration:none; border-bottom:1px dotted var(--blue)}
  .hl{background:#fff7e6; border:1px solid #ffe0a3; padding:2px 6px; border-radius:6px}

  /* Raw data tables + bars */
  .rawgrid{display:grid; grid-template-columns: 1fr; gap:14px}
  @media (min-width: 880px){ .rawgrid{grid-template-columns: 1fr 1fr} }
  .card{background:#fff; border:1px solid var(--border); border-radius:12px; padding:12px 14px}
  .kv{display:grid; grid-template-columns: 160px 1fr; gap:8px; margin:4px 0}
  .bar{height:10px; background:#edf1f7; border:1px solid var(--border); border-radius:12px; overflow:hidden}
  .bar > div{height:100%}
  .bar.derivation > div{background:#cbe8ff}
  .bar.minimization > div{background:#d5ffe3}
  .bar.activation > div{background:#ffe6cc}
  .bar.equilibrium > div{background:#e2dcff}
  .bar.copy > div{background:#ffd6e0}
  .mini{font-size:.9rem; color:var(--muted)}
  details summary{cursor:pointer; user-select:none}
</style>
</head>
<body>
<div class="wrap">
  <h1>The Infite Game of the Insight Economy — P3 Triad Demo</h1>

  <div class="panel">
    <p><strong>What this is.</strong> A compact, hands-on model of an <em>insight economy</em> that prefers <em>deriving answers in place</em> over copying raw data around. Instead of hoarding, it rewards timely, purpose-limited answers that expire, are rate-limited, and come with guardrails. The goal is to play the <em>infinite game</em>: create durable value without burning trust.</p>
    <p><strong>Why it matters.</strong> Copying data invites breach risk, consent drift, and extractive incentives. Computing near the data (federated, zero-copy) reduces blast radius, makes minimization real, and nudges business models toward <em>activation</em> (value from using an answer) rather than <em>possession</em> (value from owning the data).</p>
    <p><strong>How to use.</strong> Pick a scenario, then read: <span class="hl">Answer</span> (pass/fail and summary), <span class="hl">Reason Why</span> (narrative with pillar scores and flags), <span class="hl">Raw inputs &amp; derived scores</span> (what you chose and what the system computed), and <span class="hl">Check</span> (invariants + unit tests). Everything runs locally—no network calls.</p>

    <p>Instead of copying and storing people’s raw data, compute a small, useful <em>answer</em> right where the data lives, and share just that answer. Align technology, legal rules, and business incentives so this stays respectful and useful over time.</p>
    <p>We evaluate each scenario on five simple things:</p>
    <ul>
      <li><strong>Derivation</strong> — Do you compute the answer <em>near the data</em> (e.g., zero-copy, on-site, federated)?</li>
      <li><strong>Minimization</strong> — Do you use the <em>least data</em> needed, with a clear purpose and safeguards?</li>
      <li><strong>Activation</strong> — Do you create value from the <em>answer</em> (not from owning raw data)?</li>
      <li><strong>Equilibrium</strong> — Are technology, legal, and business well balanced? (A three-legged stool.)</li>
      <li><strong>Copy-Resistance</strong> — Is the answer less useful if copied around (short-lived, rate-limited, contractual)?</li>
    </ul>
    <p><span class="pill info">Rule to pass</span> A scenario is <strong>infinite-minded</strong> if its average score is <span class="hl">≥ 0.60</span>, at least <span class="hl">3</span> pillars score <span class="hl">≥ 0.60</span>, and the <em>penalty</em> from red flags is <span class="hl">&lt; 0.25</span>. Otherwise it’s <strong>finite-minded</strong>.</p>
    <p class="muted"><em>Determinism.</em> With the same inputs you’ll get the same scores and pass/fail result. The model is intentionally minimal—extend pillars, tags, or thresholds to fit your domain.</p>
  </div>

  <h2>Under the hood — what’s happening</h2>
  <div class="panel">
    <p><strong>Inputs.</strong> Each scenario has a few <em>traits</em> (sliders from 0..1 for tech/legal/business/copy-resistance) and a few <em>decisions</em> tagged with everyday words like <code>zero_copy</code>, <code>purpose_limited</code>, or <code>raw_export</code>.</p>
    <p><strong>Scoring.</strong> Helpful tags nudge a pillar up a little, harmful tags push it down a little. We keep every score between 0 and 1. <em>Equilibrium</em> rewards balance across tech/legal/business — if one leg of the stool is short, the balance score drops.</p>
    <p><strong>Penalties.</strong> Certain red-flag behaviors add <code>0.15</code> each to a penalty total: <em>raw data exports</em>, <em>data-hoarding business models</em>, and <em>broad consent/profiling without minimization</em>. Too many flags → finite-minded.</p>
    <p><strong>Checks for trust.</strong> A built-in test harness runs <em>in this page</em>. It checks the math, threshold rules, and common edge cases. You’ll see a clear PASS/FAIL for each check below.</p>
  </div>

  <h2>Answer</h2>
  <div id="answer" class="panel scoreboard"></div>

  <h2>Reason Why</h2>
  <div id="reasons" class="panel"></div>

  <h2>Raw inputs & derived scores</h2>
  <div id="raw" class="panel"></div>

  <h2>Check</h2>
  <div id="checks" class="panel"></div>

  <p class="muted">Everything runs locally in your browser. No network calls. You can view the source to see exactly how it works.</p>
</div>

<script>
/* ===========================
   Data
   =========================== */
const DATA = [
  {
    name: "Delfour ↔ Community Pharmacy (insight request)",
    context: "Supermarket asks pharmacy for a fit-for-purpose insight about likely sugar-sensitive purchases; compute near data.",
    traits: {tech_maturity:0.80, legal_maturity:0.78, biz_maturity:0.76, copy_resistance:0.85},
    decisions: [
      {year:2025, description:"Derive prediction at pharmacy; send only a yes/no + confidence", tags:["on_site_derivation","zero_copy","data_minimized"]},
      {year:2025, description:"Contract governs the insight (not data), revocable and auditable", tags:["insight_contract","expiry","auditability","purpose_limited"]},
      {year:2025, description:"Per-insight pricing with shared upside if conversion occurs", tags:["pay_per_insight","mutual_value"]},
    ],
  },
  {
    name: "Mobility Pass ↔ City Parking (dynamic pricing via insights)",
    context: "Driver keeps telemetry; parking operator requests a congestion/availability insight to set dynamic rates—no raw movement data leaves.",
    traits:{tech_maturity:0.77, legal_maturity:0.80, biz_maturity:0.74, copy_resistance:0.82},
    decisions: [
      {year:2024, description:"Federated compute of congestion index from user devices", tags:["federated_compute","on_site_derivation","zero_copy"]},
      {year:2024, description:"Purpose-limited, legitimate-interest assessment for traffic management", tags:["purpose_limited","legitimate_interest","data_minimized"]},
      {year:2025, description:"Pay-per-insight with rate limits & short-lived tokens", tags:["pay_per_insight","rate_limited","expiry"]},
    ],
  },
  {
    name: "Clinical Research Board ↔ EHR Network (trial feasibility)",
    context:"Hospitals compute cohort counts locally; the broker receives only k-anonymized counts and eligibility flags.",
    traits:{tech_maturity:0.81, legal_maturity:0.83, biz_maturity:0.70, copy_resistance:0.80},
    decisions: [
      {year:2023, description:"k-anon cohort counts; no row-level exports", tags:["on_site_derivation","zero_copy","data_minimized"]},
      {year:2023, description:"Ethics & legal review confirm minimization suffices", tags:["purpose_limited","legitimate_interest"]},
      {year:2024, description:"Per-site incentives tied to use of the insight, not data volume", tags:["mutual_value","pay_per_insight"]},
    ],
  },
  {
    name:"AdTech Broker (warehouse the web)",
    context:"Collects raw browsing and app telemetry into a central lake; derives value mainly from copying & reselling profiles.",
    traits:{tech_maturity:0.62, legal_maturity:0.25, biz_maturity:0.65, copy_resistance:0.20},
    decisions:[
      {year:2022, description:"Raw event export from SDKs into central warehouse", tags:["raw_export","warehouse_merge"]},
      {year:2023, description:"Broad consents; profiling without minimization", tags:["broad_consent","profiling_no_min"]},
      {year:2025, description:"Claims 'ownership' of user data, resale to partners", tags:["data_ownership_claims"]},
    ],
  },
  {
    name:"Insurer Bulk EHR Import (risk scoring)",
    context:"Seeks bulk EHR copies for risk models; aims to keep a permanent lake.",
    traits:{tech_maturity:0.55, legal_maturity:0.35, biz_maturity:0.60, copy_resistance:0.30},
    decisions:[
      {year:2024, description:"Requests CSV exports of medical records", tags:["raw_export"]},
      {year:2024, description:"Broad, evergreen consents", tags:["broad_consent"]},
      {year:2025, description:"Central model training without minimization", tags:["profiling_no_min","warehouse_merge"]},
    ],
  },
];

/* ===========================
   Scoring utilities
   =========================== */
const THRESH_AVG = 0.60;
const THRESH_STRONG = 0.60;

const clamp01 = x => Math.max(0, Math.min(1, x));
const roundPct = x => `${Math.round(x*100)}%`;
const toPctNum = x => Math.round(x*100);
const uniq = arr => [...new Set(arr)];

function scoreDerivation(s){
  const base = 0.6 * (s.traits.tech_maturity ?? 0.5);
  const boosts = s.decisions.filter(d => d.tags.some(t => ["on_site_derivation","federated_compute","zero_copy"].includes(t))).length;
  let score = base + Math.min(0.35, boosts * 0.18);
  const reasons = boosts ? ["Derives insights near data (zero-copy/federated)."] : [];
  return {score: clamp01(score), reasons, meta:{base, boosts}};
}

function scoreMinimization(s){
  const base = 0.6 * (s.traits.legal_maturity ?? 0.5);
  const good = s.decisions.filter(d => d.tags.some(t => ["data_minimized","purpose_limited","legitimate_interest","expiry","auditability"].includes(t))).length;
  const bad  = s.decisions.filter(d => d.tags.some(t => ["broad_consent","profiling_no_min"].includes(t))).length;
  let score = base + Math.min(0.35, good * 0.17) - Math.min(0.35, bad * 0.20);
  const reasons = good ? ["Minimizes data with purpose limits & safeguards."] : [];
  const flags = bad ? ["Broad/profiling without minimization."] : [];
  return {score: clamp01(score), reasons, flags, meta:{base, good, bad}};
}

function scoreActivation(s){
  const base = 0.6 * (s.traits.biz_maturity ?? 0.5);
  const pro = s.decisions.filter(d => d.tags.some(t => ["insight_contract","pay_per_insight","mutual_value","rate_limited"].includes(t))).length;
  const bad = s.decisions.filter(d => d.tags.some(t => ["warehouse_merge","data_ownership_claims"].includes(t))).length;
  let score = base + Math.min(0.35, pro * 0.16) - Math.min(0.35, bad * 0.18);
  const reasons = pro ? ["Value via insight contracts / pay-per-insight / mutual gain."] : [];
  const flags = bad ? ["Data-hoarding business model."] : [];
  return {score: clamp01(score), reasons, flags, meta:{base, pro, bad}};
}

function scoreEquilibrium(der, minz, act){
  const vals = [der,minz,act];
  const mu = (der+minz+act)/3;
  const variance = vals.reduce((a,v)=>a+Math.pow(v-mu,2),0)/3;
  const maxVar = (Math.pow(1-1/3,2) + Math.pow(0-1/3,2) + Math.pow(0-1/3,2))/3;
  const balance = 1 - (variance/maxVar);
  const score = clamp01(0.2 + 0.8 * balance);
  const reasons = [balance >= 0.7 ? "Balanced Trinity across tech/legal/business." : "Trinity slightly imbalanced."];
  return {score, reasons, meta:{balance}};
}

function scoreCopyResistance(s){
  const base = 0.6 * (s.traits.copy_resistance ?? 0.5);
  const supports = s.decisions.filter(d => d.tags.some(t => ["rate_limited","expiry","insight_contract"].includes(t))).length;
  let score = base + Math.min(0.35, supports * 0.16);
  const reasons = supports ? ["Copy-resistant via contract/expiry/rate limits."] : [];
  let flags = [];
  let multiplied = false;
  if (s.decisions.some(d => d.tags.includes("raw_export"))) {
    score *= 0.6;
    flags.push("Raw data exports undermine copy-resistance.");
    multiplied = true;
  }
  return {score: clamp01(score), reasons, flags, meta:{base, supports, multiplied}};
}

function evaluateScenario(s){
  const d = scoreDerivation(s);
  const m = scoreMinimization(s);
  const a = scoreActivation(s);
  const e = scoreEquilibrium(d.score, m.score, a.score);
  const c = scoreCopyResistance(s);

  const pillars = {
    "Derivation": d.score,
    "Minimization": m.score,
    "Activation": a.score,
    "Equilibrium": e.score,
    "Copy-Resistance": c.score,
  };
  const reasonsMap = {
    "Derivation": d.reasons,
    "Minimization": m.reasons,
    "Activation": a.reasons,
    "Equilibrium": e.reasons,
    "Copy-Resistance": c.reasons,
  };
  const flags = uniq([...(m.flags||[]), ...(a.flags||[]), ...(c.flags||[])]);
  const avg = (Object.values(pillars).reduce((x,y)=>x+y,0))/5;
  const strong = Object.values(pillars).filter(v => v >= THRESH_STRONG).length;

  let penalty = 0.0;
  if (flags.includes("Broad/profiling without minimization.")) penalty += 0.15;
  if (flags.includes("Data-hoarding business model."))        penalty += 0.15;
  if (flags.includes("Raw data exports undermine copy-resistance.")) penalty += 0.15;

  const infinite = (avg >= THRESH_AVG && strong >= 3 && penalty < 0.25);
  const classification = infinite ? "infinite-minded" : "finite-minded";

  let reason = `Avg ${roundPct(avg)} with ${strong}/5 elements ≥${Math.round(THRESH_STRONG*100)}%. ` +
               `Classification: ${classification.toUpperCase()}.`;
  const brief = [];
  for (const [k, lst] of Object.entries(reasonsMap)) if (lst.length) brief.push(`${k}: ${lst.join(", ")}`);
  if (flags.length) brief.push("Red flags: " + flags.join("; "));
  if (brief.length) reason += " " + brief.join(" ");

  return { name: s.name, classification, pillars, average: avg, strong, reason_text: reason,
           flags, penalty, context: s.context, reasons_map: reasonsMap,
           meta:{d,m,a,e,c} };
}

/* ===========================
   Check catalog
   =========================== */
const INVARIANT_INFO = {
  I1:"average equals mean of pillars",
  I2:"each pillar within [0,1]",
  I3:"strong_count matches pillars ≥ 0.60",
  I4:"if infinite-minded then (avg/strong/penalty) preconditions hold",
  I5:"if penalty ≥ 0.25 then must be finite-minded",
  I6:"narrative includes canonical label",
  I7:"reasons_map keys match pillar keys",
  I8:"average between min and max pillar values",
  I9:"deterministic: re-evaluation matches",
  I10:"zero flags + thresholds ⇒ infinite-minded",
  I11:"all pillars ≥ 0.70 ⇒ infinite-minded",
  I12:"raw_export present ⇒ narrative includes raw-export flag",
  I13:"thresholds met & penalty < 0.25 ⇒ infinite-minded (contrapositive)",
  I14:"penalty equals 0.15 × distinct flag buckets",
  I15:"very imbalanced Trinity ⇒ low Equilibrium",
  I16:"near-equal Trinity ⇒ high Equilibrium",
};

const UNIT_INFO = {
  U1:"All-High-Insight ⇒ infinite-minded",
  U2:"All-Low-DataLake ⇒ finite-minded",
  U3:"Near-But-Avg-Below (avg below) ⇒ finite-minded",
  U4:"Avg-High-But-Flagged (penalty ≥0.25) ⇒ finite-minded",
  U5:"Imbalanced-Trinity doesn’t sneak through on average alone",
  U6:"Finite wording alone doesn’t block if Trinity holds",
  U7:"Monotonicity: adding supportive tag doesn’t reduce Derivation",
  U8:"One flag (0.15) with high pillars can still be infinite-minded",
  U9:"Two flags (0.30) force finite-minded",
  U10:"Removing raw_export raises Copy-Resistance",
};

/* ===========================
   Invariants & unit tests
   =========================== */
function runInvariants(results) {
  const out = {}; Object.keys(INVARIANT_INFO).forEach(k => out[k]=[]);
  const nameToObj = Object.fromEntries(DATA.map(s => [s.name, s]));

  // I1..I8 basics
  for (const r of results) {
    // I1
    const expected = Object.values(r.pillars).reduce((x,y)=>x+y,0)/5;
    if (Math.abs(r.average - expected) > 1e-9)
      out.I1.push(`${r.name}: average mismatch (${r.average.toFixed(3)} vs ${expected.toFixed(3)})`);

    // I2
    for (const [k,v] of Object.entries(r.pillars))
      if (!(v >= -1e-9 && v <= 1+1e-9))
        out.I2.push(`${r.name}: pillar '${k}'=${v.toFixed(3)} out of [0,1]`);

    // I3
    const strongCount = Object.values(r.pillars).filter(v => v >= THRESH_STRONG).length;
    if (strongCount !== r.strong)
      out.I3.push(`${r.name}: strong_count ${r.strong} vs ${strongCount}`);

    // I4
    if (r.classification === "infinite-minded") {
      if (!(r.average >= THRESH_AVG && r.strong >= 3 && r.penalty < 0.25))
        out.I4.push(`${r.name}: infinite-minded but rule not satisfied`);
    }

    // I5
    if (r.penalty >= 0.25 && r.classification !== "finite-minded")
      out.I5.push(`${r.name}: penalty ${r.penalty.toFixed(2)} but not finite-minded`);

    // I6
    const needed = r.classification === "infinite-minded" ? "Classification: INFINITE-MINDED." : "Classification: FINITE-MINDED.";
    if (!r.reason_text.includes(needed))
      out.I6.push(`${r.name}: missing canonical label in narrative`);

    // I7
    if (Object.keys(r.reasons_map).sort().join("|") !== Object.keys(r.pillars).sort().join("|"))
      out.I7.push(`${r.name}: reasons keys mismatch pillars`);

    // I8
    const vals = Object.values(r.pillars);
    if (!(Math.min(...vals)-1e-9 <= r.average && r.average <= Math.max(...vals)+1e-9))
      out.I8.push(`${r.name}: average not between min/max pillars`);
  }

  // I9 determinism (evaluate again from source)
  for (const r of results) {
    const src = nameToObj[r.name];
    if (!src) { out.I9.push(`${r.name}: missing source for determinism`); continue; }
    const r2 = evaluateScenario(src);
    if (Math.abs(r2.average - r.average) > 1e-9 || r2.classification !== r.classification || r2.strong !== r.strong)
      out.I9.push(`${r.name}: non-deterministic evaluation`);
  }

  // I10 zero flags + thresholds ⇒ infinite-minded
  for (const r of results) {
    if (r.flags.length===0 && r.average >= THRESH_AVG && r.strong >= 3 && r.classification !== "infinite-minded")
      out.I10.push(`${r.name}: thresholds met w/o flags but not infinite-minded`);
  }

  // I11 all pillars strong ⇒ infinite-minded
  for (const r of results) {
    if (Object.values(r.pillars).every(v => v >= 0.70) && r.classification !== "infinite-minded")
      out.I11.push(`${r.name}: all pillars strong but not infinite-minded`);
  }

  // I12 raw_export ⇒ narrative has explicit flag
  for (const r of results) {
    const src = nameToObj[r.name];
    const hasRaw = src?.decisions?.some(d => d.tags.includes("raw_export"));
    if (hasRaw && !r.reason_text.includes("Raw data exports undermine copy-resistance."))
      out.I12.push(`${r.name}: raw_export present but narrative lacks explicit flag`);
  }

  // I13 thresholds met + penalty<0.25 ⇒ infinite-minded
  for (const r of results) {
    if (r.average >= THRESH_AVG && r.strong >= 3 && r.penalty < 0.25 && r.classification !== "infinite-minded")
      out.I13.push(`${r.name}: thresholds met but classification not infinite-minded`);
  }

  // I14 penalty math
  for (const r of results) {
    let expected = 0.0;
    if (r.flags.includes("Broad/profiling without minimization.")) expected += 0.15;
    if (r.flags.includes("Data-hoarding business model.")) expected += 0.15;
    if (r.flags.includes("Raw data exports undermine copy-resistance.")) expected += 0.15;
    if (Math.abs(expected - r.penalty) > 1e-9)
      out.I14.push(`${r.name}: expected ${expected.toFixed(2)}, got ${r.penalty.toFixed(2)}`);
  }

  // I15 very imbalanced Trinity ⇒ low Equilibrium
  for (const r of results) {
    const d=r.pillars["Derivation"], m=r.pillars["Minimization"], a=r.pillars["Activation"];
    const mu=(d+m+a)/3, std=Math.sqrt(((mu-d)**2+(mu-m)**2+(mu-a)**2)/3);
    if (std>=0.45 && !(r.pillars["Equilibrium"] <= 0.40+1e-9))
      out.I15.push(`${r.name}: high imbalance (std=${std.toFixed(2)}) but Equilibrium=${r.pillars["Equilibrium"].toFixed(2)} not low`);
  }

  // I16 near-equal Trinity ⇒ high Equilibrium
  for (const r of results) {
    const d=r.pillars["Derivation"], m=r.pillars["Minimization"], a=r.pillars["Activation"];
    if (Math.max(d,m,a) - Math.min(d,m,a) <= 0.05 && r.pillars["Equilibrium"] < 0.85-1e-9)
      out.I16.push(`${r.name}: near-equal Trinity but Equilibrium=${r.pillars["Equilibrium"].toFixed(2)} not high`);
  }
  return out;
}

function runUnitTests() {
  const out = {}; Object.keys(UNIT_INFO).forEach(k => out[k]=[]);

  // U1: All-High-Insight → infinite-minded
  let s = {name:"All-High-Insight", context:"Synthetic", traits:{tech_maturity:0.9,legal_maturity:0.9,biz_maturity:0.9,copy_resistance:0.9},
           decisions:[{year:2025,description:"good",tags:["on_site_derivation","zero_copy","data_minimized","purpose_limited","insight_contract","pay_per_insight","rate_limited","expiry"]}]};
  let r = evaluateScenario(s);
  if (r.classification!=="infinite-minded") out.U1.push("Expected infinite-minded");

  // U2: All-Low-DataLake → finite-minded
  s = {name:"All-Low-DataLake", context:"Synthetic", traits:{tech_maturity:0.2,legal_maturity:0.2,biz_maturity:0.2,copy_resistance:0.2},
       decisions:[{year:2025,description:"bad",tags:["raw_export","warehouse_merge","broad_consent","profiling_no_min","data_ownership_claims"]}]};
  r = evaluateScenario(s);
  if (r.classification!=="finite-minded") out.U2.push("Expected finite-minded");

  // U3: Avg definitively below threshold → finite-minded (uses 0.55 baselines)
  s = {name:"Near-But-Avg-Below", context:"Synthetic", traits:{tech_maturity:0.55,legal_maturity:0.55,biz_maturity:0.55,copy_resistance:0.55},
       decisions:[{year:2025,description:"mostly good",tags:["on_site_derivation","data_minimized","insight_contract"]}]};
  r = evaluateScenario(s);
  if (r.average >= THRESH_AVG || r.classification!=="finite-minded") out.U3.push("Should be finite-minded with avg below threshold");

  // U4: Avg above threshold but penalty ≥ 0.25 → finite-minded
  s = {name:"Avg-High-But-Flagged", context:"Synthetic", traits:{tech_maturity:0.75,legal_maturity:0.75,biz_maturity:0.75,copy_resistance:0.75},
       decisions:[{year:2025,description:"good+bad",tags:["on_site_derivation","data_minimized","insight_contract","raw_export","warehouse_merge"]}]};
  r = evaluateScenario(s);
  if (!(r.average >= THRESH_AVG && r.penalty >= 0.25 && r.classification==="finite-minded"))
    out.U4.push("Penalty ≥0.25 should force finite-minded");

  // U5: Imbalanced Trinity shouldn't pass just on avg/strong
  s = {name:"Imbalanced-Trinity", context:"Synthetic", traits:{tech_maturity:0.9,legal_maturity:0.9,biz_maturity:0.35,copy_resistance:0.7},
       decisions:[{year:2025,description:"mixed",tags:["on_site_derivation","data_minimized"]}]};
  r = evaluateScenario(s);
  if (r.average >= THRESH_AVG && r.strong >= 3 && r.classification==="infinite-minded")
    out.U5.push("Imbalance should prevent easy pass");

  // U6: Finite wording alone shouldn't block if trinity holds (0.72 baselines)
  s = {name:"Finite-Sounding-But-OK", context:"Synthetic", traits:{tech_maturity:0.72,legal_maturity:0.72,biz_maturity:0.72,copy_resistance:0.72},
       decisions:[{year:2025,description:"good",tags:["on_site_derivation","data_minimized","insight_contract","rate_limited","expiry"]}]};
  r = evaluateScenario(s);
  if (r.classification!=="infinite-minded") out.U6.push("Finite wording alone should not block");

  // U7: Monotonicity — adding supportive tag increases (or preserves) Derivation
  const base = {name:"Mono-Base", context:"Synthetic", traits:{tech_maturity:0.6,legal_maturity:0.6,biz_maturity:0.6,copy_resistance:0.6},
                decisions:[{year:2025,description:"",tags:[]}]};
  const more = {name:"Mono-More", context:"Synthetic", traits:base.traits,
                decisions:[{year:2025,description:"",tags:["on_site_derivation"]}]};
  const rA = evaluateScenario(base), rB = evaluateScenario(more);
  if (rB.pillars["Derivation"] < rA.pillars["Derivation"] - 1e-9)
    out.U7.push("Supportive tag should not reduce Derivation");

  // U8: One flag at 0.15 with high pillars → still infinite-minded
  s = {name:"One-Flag-High", context:"Synthetic", traits:{tech_maturity:0.9,legal_maturity:0.9,biz_maturity:0.9,copy_resistance:0.9},
       decisions:[{year:2025,description:"",tags:["on_site_derivation","data_minimized","insight_contract","rate_limited","expiry","raw_export"]}]};
  r = evaluateScenario(s);
  if (!(Math.abs(r.penalty - 0.15)<1e-9 && r.classification==="infinite-minded"))
    out.U8.push("One flag shouldn’t flip classification if avg/strong hold");

  // U9: Two flags (0.30) force finite-minded
  s = {name:"Two-Flags-High", context:"Synthetic", traits:{tech_maturity:0.9,legal_maturity:0.9,biz_maturity:0.9,copy_resistance:0.9},
       decisions:[{year:2025,description:"",tags:["on_site_derivation","data_minimized","insight_contract","rate_limited","expiry","raw_export","warehouse_merge"]}]};
  r = evaluateScenario(s);
  if (!(Math.abs(r.penalty - 0.30)<1e-9 && r.classification==="finite-minded"))
    out.U9.push("Two flags should force finite-minded");

  // U10: Removing raw_export raises Copy-Resistance
  const withExp = {name:"CR-With-Export", context:"Synthetic", traits:{tech_maturity:0.7,legal_maturity:0.7,biz_maturity:0.7,copy_resistance:0.7},
                   decisions:[{year:2025,description:"",tags:["on_site_derivation","insight_contract","raw_export"]}]};
  const noExp   = {name:"CR-No-Export", context:"Synthetic", traits:withExp.traits,
                   decisions:[{year:2025,description:"",tags:["on_site_derivation","insight_contract"]}]};
  const r1 = evaluateScenario(withExp), r2 = evaluateScenario(noExp);
  if (!(r2.pillars["Copy-Resistance"] > r1.pillars["Copy-Resistance"] - 1e-9))
    out.U10.push("Removing raw_export should raise Copy-Resistance");

  return out;
}

/* ===========================
   Renderers
   =========================== */
function renderAnswer(results) {
  const root = document.getElementById("answer");
  const map = Object.fromEntries(results.map(r => [r.name, r.classification]));
  const rows = results.map(r => {
    const cls = r.classification;
    const label = cls==='infinite-minded' ? '✓ infinite-minded' : '✗ finite-minded';
    return `<tr>
      <td><strong>${r.name}</strong><div class="muted" style="font-size:.9rem">${r.context}</div></td>
      <td>${roundPct(r.average)}</td>
      <td>${r.strong}/5</td>
      <td>${r.penalty.toFixed(2)}</td>
      <td><span class="pill ${cls==='infinite-minded'?'pass':'fail'}">${label}</span></td>
    </tr>`;
  }).join("");
  root.innerHTML = `
    <div class="muted" style="margin-bottom:8px">
      Higher average and more strong pillars (≥ 60%) mean more infinite-minded.
      Penalty comes from red flags; if it reaches 0.25 or more, the scenario fails.
    </div>
    <table>
      <thead><tr>
        <th>Scenario</th><th>Average</th><th>Strong Pillars</th><th>Penalty</th><th>Result</th>
      </tr></thead>
      <tbody>${rows}</tbody>
    </table>
    <h3>Answer (as JSON)</h3>
    <pre>${JSON.stringify(map, null, 2)}</pre>
  `;
}

function renderReasons(results) {
  const root = document.getElementById("reasons");
  root.innerHTML = results.map(r => `
    <div style="margin:10px 0">
      <div style="font-weight:600">${r.name}</div>
      <div>${r.reason_text}</div>
      ${r.flags.length ? `<div style="margin-top:6px">${r.flags.map(f=>`<span class="tag">${f}</span>`).join("")}</div>` : ""}
    </div>
  `).join("<hr style='border:0;border-top:1px dashed var(--border);margin:10px 0'>");
}

/* Bars + raw inputs per scenario */
function barRow(label, value, cls){
  const pct = Math.round(value*100);
  return `
    <div class="kv">
      <div><span class="mini">${label}</span></div>
      <div>
        <div class="bar ${cls}"><div style="width:${pct}%"></div></div>
        <div class="mini" style="margin-top:2px">${pct}%</div>
      </div>
    </div>
  `;
}

function renderRaw(results){
  const root = document.getElementById("raw");
  const blocks = results.map((r, idx) => {
    const s = DATA[idx]; // original inputs
    const traits = Object.entries(s.traits).map(([k,v]) => `<div class="kv"><div class="mini">${k}</div><div>${v.toFixed(2)}</div></div>`).join("");
    const decisions = s.decisions.map(d => `
      <div class="kv">
        <div class="mini">${d.year}</div>
        <div>${d.description}<div style="margin-top:4px">${d.tags.map(t=>`<span class="tag">${t}</span>`).join("")}</div></div>
      </div>
    `).join("");

    const bars = [
      barRow("Derivation", r.pillars["Derivation"], "derivation"),
      barRow("Minimization", r.pillars["Minimization"], "minimization"),
      barRow("Activation", r.pillars["Activation"], "activation"),
      barRow("Equilibrium", r.pillars["Equilibrium"], "equilibrium"),
      barRow("Copy-Resistance", r.pillars["Copy-Resistance"], "copy"),
    ].join("");

    const flags = r.flags.length ? r.flags.map(f=>`<span class="tag">${f}</span>`).join("") : "<span class='mini'>None</span>";

    return `
      <details class="card" ${idx<2 ? "open": ""}>
        <summary><strong>${r.name}</strong> — inputs & scores</summary>
        <div class="rawgrid" style="margin-top:10px">
          <div>
            <h3>Traits</h3>
            ${traits}
            <h3 style="margin-top:10px">Decisions</h3>
            ${decisions}
          </div>
          <div>
            <h3>Derived pillar scores</h3>
            ${bars}
            <div class="kv"><div class="mini"><strong>Average</strong></div><div><strong>${toPctNum(r.average)}%</strong></div></div>
            <div class="kv"><div class="mini"><strong>Strong pillars</strong></div><div><strong>${r.strong}/5</strong></div></div>
            <div class="kv"><div class="mini"><strong>Penalty</strong></div><div><strong>${r.penalty.toFixed(2)}</strong></div></div>
            <div class="kv"><div class="mini"><strong>Flags</strong></div><div>${flags}</div></div>
          </div>
        </div>
      </details>
    `;
  }).join("");

  root.innerHTML = blocks;
}

function yesno(b){ return b ? `<span class="pill pass">✓ PASS</span>` : `<span class="pill fail">✗ FAIL</span>` }

function renderChecks(invIssues, unitIssues) {
  const root = document.getElementById("checks");
  const invTotal = Object.keys(INVARIANT_INFO).length;
  const unitTotal = Object.keys(UNIT_INFO).length;
  const invPassCount = Object.keys(INVARIANT_INFO).filter(k => !invIssues[k]?.length).length;
  const unitPassCount = Object.keys(UNIT_INFO).filter(k => !unitIssues[k]?.length).length;
  const allOk = invPassCount === invTotal && unitPassCount === unitTotal;

  const invRows = Object.keys(INVARIANT_INFO).sort((a,b)=>+a.slice(1)-+b.slice(1)).map(code => {
    const passed = !(invIssues[code]?.length);
    const msgs = (invIssues[code]||[]).map(m => `<div class="msg">• ${m}</div>`).join("");
    return `<div class="row">
      <div class="code">${code}</div>
      <div class="msg"><strong>${INVARIANT_INFO[code]}</strong>${msgs?'<div style="margin-top:4px"></div>':''}${msgs}</div>
      <div class="status">${yesno(passed)}</div>
    </div>`;
  }).join("");

  const unitRows = Object.keys(UNIT_INFO).sort((a,b)=>+a.slice(1)-+b.slice(1)).map(code => {
    const passed = !(unitIssues[code]?.length);
    const msgs = (unitIssues[code]||[]).map(m => `<div class="msg">• ${m}</div>`).join("");
    return `<div class="row">
      <div class="code">${code}</div>
      <div class="msg"><strong>${UNIT_INFO[code]}</strong>${msgs?'<div style="margin-top:4px"></div>':''}${msgs}</div>
      <div class="status">${yesno(passed)}</div>
    </div>`;
  }).join("");

  root.innerHTML = `
    <div>Checks run: ${invTotal} invariants + ${unitTotal} unit tests = <strong>${invTotal + unitTotal}</strong> total</div>
    <h3>Invariants (always-true properties)</h3>
    <div class="checks">${invRows}</div>
    <h3 style="margin-top:10px">Unit Tests (edge examples)</h3>
    <div class="checks">${unitRows}</div>
    <div class="summary">
      <div class="box">Invariants: <strong>${invPassCount}/${invTotal}</strong> PASS</div>
      <div class="box">Unit tests: <strong>${unitPassCount}/${unitTotal}</strong> PASS</div>
      <div class="box">OVERALL: <strong style="color:${allOk?'var(--green)':'var(--red)'}">${allOk?'PASS':'FAIL'}</strong></div>
    </div>
  `;
}

/* ===========================
   Run
   =========================== */
(function main(){
  const results = DATA.map(evaluateScenario);
  const invIssues = runInvariants(results);
  const unitIssues = runUnitTests();

  renderAnswer(results);
  renderReasons(results);
  renderRaw(results);
  renderChecks(invIssues, unitIssues);
})();
</script>
</body>
</html>

