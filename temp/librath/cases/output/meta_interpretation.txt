Answer
------
Query:
  true :+ mi([mi([factorial(s^5(0), F)], [])], []).
Result:
  F (Peano) : s^120(0)
  F (int)   : 120

Reason why
----------
We run the meta-interpreter `mi/2` exactly as in the Prolog program,
rewriting the leftmost goal each step using `head_body_/3`:
   1. factorial(s(N), F)  ⇒  [factorial(N, F1), prod(s(N), F1, F)]
   2. mi([G|Gs], [])  ⇒  mi(Goals, []) where Goals = body(factorial(s(s(s(s(s(0))))), F_1)) ++ Gs
   3. mi([G|Gs], [])  ⇒  mi(Goals, []) where Goals = body(mi([factorial(s(s(s(s(s(0))))), F_1)], [])) ++ Gs
   4. factorial(s(N), F)  ⇒  [factorial(N, F1), prod(s(N), F1, F)]
   5. mi([G|Gs], [])  ⇒  mi(Goals, []) where Goals = body(factorial(s(s(s(s(0)))), F1_4)) ++ Gs
   6. mi([G|Gs], [])  ⇒  mi(Goals, []) where Goals = body(mi([factorial(s(s(s(s(0)))), F1_4), prod(s(s(s(s(s(0))))), F1_4, F_3)], [])) ++ Gs
   7. factorial(s(N), F)  ⇒  [factorial(N, F1), prod(s(N), F1, F)]
   8. mi([G|Gs], [])  ⇒  mi(Goals, []) where Goals = body(factorial(s(s(s(0))), F1_7)) ++ Gs
   9. mi([G|Gs], [])  ⇒  mi(Goals, []) where Goals = body(mi([factorial(s(s(s(0))), F1_7), prod(s(s(s(s(0)))), F1_7, F_6), prod(s(s(s(s(s(0))))), F_6, F_3)], [])) ++ Gs
  10. factorial(s(N), F)  ⇒  [factorial(N, F1), prod(s(N), F1, F)]
  11. mi([G|Gs], [])  ⇒  mi(Goals, []) where Goals = body(factorial(s(s(0)), F1_10)) ++ Gs
  12. mi([G|Gs], [])  ⇒  mi(Goals, []) where Goals = body(mi([factorial(s(s(0)), F1_10), prod(s(s(s(0))), F1_10, F_9), prod(s(s(s(s(0)))), F_9, F_6), prod(s(s(s(s(s(0))))), F_6, F_3)], [])) ++ Gs
  … 963 more rewrite steps …

Rules used (in order of matching):
  factorial(0, s(0)).
  factorial(s(N), F)  →  factorial(N, F1), prod(s(N), F1, F).
  prod(0, _, 0).
  prod(s(N), M, P)    →  prod(N, M, K), sum(K, M, P).
  sum(0, M, M).
  sum(s(N), M, s(K))  →  sum(N, M, K).

This yields factorial(5) by repeated unfolding into `prod` and `sum` over Peano numbers.

Check (harness)
----------------
OK: meta-derivation exhausted goals and F = 120 (matches Python math.factorial).
