Answer
======
N-Queens for N = 8
Total solutions: 92

Showing 3 example solutions:

Solution 1:
  Q.......
  ....Q...
  .......Q
  .....Q..
  ..Q.....
  ......Q.
  .Q......
  ...Q....
  Coordinates: (r1, c1), (r2, c5), (r3, c8), (r4, c6), (r5, c3), (r6, c7), (r7, c2), (r8, c4)

Solution 2:
  Q.......
  .....Q..
  .......Q
  ..Q.....
  ......Q.
  ...Q....
  .Q......
  ....Q...
  Coordinates: (r1, c1), (r2, c6), (r3, c8), (r4, c3), (r5, c7), (r6, c4), (r7, c2), (r8, c5)

Solution 3:
  Q.......
  ......Q.
  ...Q....
  .....Q..
  .......Q
  .Q......
  ....Q...
  ..Q.....
  Coordinates: (r1, c1), (r2, c7), (r3, c4), (r4, c6), (r5, c8), (r6, c2), (r7, c5), (r8, c3)

Reason why
==========
We place one queen per row and forbid conflicts via three sets:
  • columns used     (no two queens share a column),
  • main diagonals   (constant r−c),
  • anti-diagonals   (constant r+c).
Bitmasks track these constraints efficiently. For each row we compute
the bitmask of available columns and try each set bit recursively.
When we reach row N, we’ve built a valid board. This guarantees correctness;
bitmasks keep it fast enough to enumerate all solutions for moderate N.

Check (harness)
===============
Sample solutions for N=8 pass row/col/diagonal constraints? True
N=1: count = 1 (expected 1)  ->  OK
N=2: count = 0 (expected 0)  ->  OK
N=3: count = 0 (expected 0)  ->  OK
N=4: count = 2 (expected 2)  ->  OK
N=5: count = 10 (expected 10)  ->  OK
N=6: count = 4 (expected 4)  ->  OK
N=7: count = 40 (expected 40)  ->  OK
N=8: count = 92 (expected 92)  ->  OK
N=9: count = 352 (expected 352)  ->  OK
N=10: count = 724 (expected 724)  ->  OK
Deterministic across runs (N=8 count & sample count)? True

All checks passed? True
