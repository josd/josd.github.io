Answer
------
A  = s(s(0))   # 2
B  = s(s(s(s(s(0)))))   # 5
B! = s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))   # 120

Reason why
----------
We interpret the Prolog rules over the natural numbers:
  add(A,0,A).
  add(A,s(B),s(C)) :- add(A,B,C).
  multiply(_,0,0).
  multiply(A,s(B),C) :- multiply(A,B,D), add(A,D,C).
  factorial(N,B) :- fac(N,s(0),B) with fac(0,A,A) and fac(s(A),B,C) :- multiply(B,s(A),D), fac(A,D,C).

Applied to the query:
  1) A = multiply(s(0), s(s(0))) = 1 * 2 = 2
  2) B = add(A, s(s(s(0))))     = 2 + 3 = 5
  3) factorial(B, _)            = 5!     = 120
Each step follows the recursive clauses above; in Python we compute with ints,
then pretty-print results back as Peano terms for readability.

Check (harness)
---------------
OK: query values correct; add/multiply align with +/*; laws (comm, assoc, distrib) hold on tests; factorial OK.
