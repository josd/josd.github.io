Answer
------
Philosophers: 5, meals each: 3, total meals: 15
Eating schedule (deterministic order):
  Round 1: 0 → 1 → 2 → 3 → 4
  Round 2: 0 → 1 → 2 → 3 → 4
  Round 3: 0 → 1 → 2 → 3 → 4

Reason why
----------
We serialize eating with a condition-variable *token* (`turn`).
Only the philosopher whose id equals `turn` proceeds to grab both forks.
Everyone else waits on the condition, so no two philosophers attempt to
lock conflicting forks simultaneously. After eating, the philosopher
increments `turn` (mod N) and signals the condition.

Consequences:
  • Deadlock impossible (no circular wait; only one contender).
  • Starvation impossible (token visits philosophers round-robin).
  • Deterministic output (order 0..N−1 repeats for each round).

Check (harness)
---------------
OK: no overlap, correct order each round, correct counts, run completed.

