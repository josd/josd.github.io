Answer
======
Requested values (exact):

F_0 = 0
  (digits: 1)

F_1 = 1
  (digits: 1)

F_6 = 8
  (digits: 1)

F_91 = 4660046610375530309
  (digits: 19)

F_283 = 62232491515607091882574410635924603070626544377175485625797
  (digits: 59)

F_3674 = 295872959797101479478634366815157108100573212705250690577871041398423606408217262643449728342664061812585639168722421830407677671667740585806703531229882783069925750619720511808616484846128237251921414441458265138672827487722512845223115526738192067144721087756159352711138340620702266509343657403678256247195010013499661223527119909308682062873140767135468966093474944529418214755911968500799987099146489838560114063096775586903976827512299123202488315139397181279903459556726060805948910609527571241968534269554079076649680403030083743420820438603816095671532163428933363322524736324029745871445486444623006627119156710782085648303485296149604974010598940800770684835758031137479033374229914629583184427269638360355586190323578625395157899987377625662075558684705457
  (digits: 768)


Reason why
==========
Define Fibonacci by F_0=0, F_1=1, and F_{n+2}=F_{n+1}+F_n.
A standard addition identity (provable by induction) is:
  (A)  F_{m+n} = F_m·F_{n+1} + F_{m-1}·F_n  for m,n ≥ 1.

Specializing (A) yields fast-doubling from (F_k, F_{k+1}):
  F_{2k}   = F_k (2F_{k+1} − F_k)
  F_{2k+1} = F_{k+1}^2 + F_k^2
Hence one recursive call on k=floor(n/2) lets us compute both
F_{2k} and F_{2k+1} in O(1), and then select (F_n, F_{n+1})
depending on n’s parity. With base (F_0, F_1) = (0, 1), this gives
O(log n) exact computation using only integer arithmetic.

Check (harness)
===============
Base pair correct? True
Recurrence holds on n ∈ [0,1000)? True
Addition identity (A) holds on m∈[1,60), n∈[0,60)? True
Cross-check vs linear on n ∈ [0,2000)? True

All checks passed? True
