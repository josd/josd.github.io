========================================================================
list(GrayCode(2).generate_gray()) = ['00', '01', '11', '10']
Reason why:
  We use the binary-reflected Gray code (reflect-and-prefix):
    G(1) = ['0','1'],  G(n) = ['0'+G(n-1)] + ['1'+reverse(G(n-1))].
  Prefixing preserves Hamming distances within halves,
  the middle junction flips only the new leading bit,
  and last = '1' + '0'*(n-1) differs from first = '0'*n in 1 bit ⇒ cyclic.
Check (harness):
  length = 4 (expected 4), unique = True
  all words are 2-bit 0/1 strings = True
  adjacent Hamming distance = 1 (incl. wrap) → True (max seen 1)
  adjacent XOR is power of two → True
  equals i^(i>>1) closed-form sequence → True
========================================================================
list(GrayCode(3).generate_gray()) = ['000', '001', '011', '010', '110', '111', '101', '100']
Reason why:
  We use the binary-reflected Gray code (reflect-and-prefix):
    G(1) = ['0','1'],  G(n) = ['0'+G(n-1)] + ['1'+reverse(G(n-1))].
  Prefixing preserves Hamming distances within halves,
  the middle junction flips only the new leading bit,
  and last = '1' + '0'*(n-1) differs from first = '0'*n in 1 bit ⇒ cyclic.
Check (harness):
  length = 8 (expected 8), unique = True
  all words are 3-bit 0/1 strings = True
  adjacent Hamming distance = 1 (incl. wrap) → True (max seen 1)
  adjacent XOR is power of two → True
  equals i^(i>>1) closed-form sequence → True
========================================================================
list(GrayCode(4).generate_gray()) = ['0000', '0001', '0011', '0010', '0110', '0111', '0101', '0100', '1100', '1101', '1111', '1110', '1010', '1011', '1001', '1000']
Reason why:
  We use the binary-reflected Gray code (reflect-and-prefix):
    G(1) = ['0','1'],  G(n) = ['0'+G(n-1)] + ['1'+reverse(G(n-1))].
  Prefixing preserves Hamming distances within halves,
  the middle junction flips only the new leading bit,
  and last = '1' + '0'*(n-1) differs from first = '0'*n in 1 bit ⇒ cyclic.
Check (harness):
  length = 16 (expected 16), unique = True
  all words are 4-bit 0/1 strings = True
  adjacent Hamming distance = 1 (incl. wrap) → True (max seen 1)
  adjacent XOR is power of two → True
  equals i^(i>>1) closed-form sequence → True
