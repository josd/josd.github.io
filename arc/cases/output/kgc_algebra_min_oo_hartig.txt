Model
=====
Base mapping relations (tables), per-attribute:
• PersonsPart1: (ax, an) with tuples t1,t2 → ids 1,2; names "Alice","Bob".
• PersonsPart2: (ax, an) with tuple t3 → id 3; name "Carol".

Operator instances
------------------
Plan A (extend after union):
  UnionRel(PersonsPart1, PersonsPart2, PersonsAll)
  ExtendAsFromAx(PersonsAll, TmpA1)
  ExtendApConst(TmpA1, name, TmpA2)
  ExtendAoFromAn(TmpA2, NameTriples_A) → emit triples

Plan B (extend then union):
  ExtendAsFromAx(PersonsPart1, TmpB1_1), ExtendAsFromAx(PersonsPart2, TmpB1_2)
  ExtendApConst(TmpB1_1, name, TmpB2_1), ExtendApConst(TmpB1_2, name, TmpB2_2)
  ExtendAoFromAn(... → NameTriples_B1), (... → NameTriples_B2), UnionRel(..., NameTriples_Union) → emit triples

Lookup for subject IRIs:
  IRIOf(1)→person_1, IRIOf(2)→person_2, IRIOf(3)→person_3

Question
========
Q1) Enumerate triples ex:name(S,O) from Plan A and from Plan B.
Q2) Check equivalence: Extend(Union(P1,P2)) vs Union(Extend(P1),Extend(P2)).
Q3) Ground check: ex:name(ex:person_2, "Bob") ?

Answer
======
Q1)
  Plan A (Extend after Union): ex:name = {⟨ex:person_1,"Alice"⟩, ⟨ex:person_2,"Bob"⟩, ⟨ex:person_3,"Carol"⟩}
  Plan B (Extend then Union) : ex:name = {⟨ex:person_1,"Alice"⟩, ⟨ex:person_2,"Bob"⟩, ⟨ex:person_3,"Carol"⟩}
Q2) Equivalence holds (sets equal): Yes
Q3) holds2(ex:name, ex:person_2, "Bob"): Yes

Reason why
==========
• Mapping relations are represented by per-attribute tables R/ax, R/an, R/as, R/ap, R/ao.
• Algebra operators (Union, ExtendAsFromAx, ExtendApConst, ExtendAoFromAn) are implemented
  as specialized Python functions over these tables.
• Triples are emitted by reading as/ap/ao and adding triples (P,S,O) to a TripleStore.
• This mirrors the algebraic plan view in Min Oo & Hartig (ESWC 2025), where operators
  compose into plans and equivalences (rewrite rules) ensure semantics-preserving rewrites.
• Here we validate the classic rewrite Extend ∘ Union  ≡  Union ∘ (Extend, Extend).

Check (harness)
===============
PASS 1: Subjects {Alice,Bob,Carol} present.
PASS 2: Objects {"Alice","Bob","Carol"} present.
PASS 3: Extend over Union equivalence holds (A == B == global).
PASS 4: Ground positive triple for Bob present.
PASS 5: Negative ground case (Bob,Alice) is blocked.
PASS 6: UnionRel covers all ids {1,2,3} with tuples {t1,t2,t3}.
PASS 7: ExtendAsFromAx populates subjects ex:person_1/2/3.
PASS 8: ExtendApConst populates predicates ex:name in plan A.
PASS 9: ExtendAoFromAn populates objects "Alice","Bob","Carol" in plan A.
PASS 10: Plan B parts (B1,B2) partition and union correctly.
PASS 11: Model rebuilding is stable (idempotent wrt ex:name).
PASS 12: Pretty-printing of triples is deterministic.
