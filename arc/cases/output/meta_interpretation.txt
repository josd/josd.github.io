Answer
------
Query:
 true :+ mi([mi([factorial(s^5(0), F)], [])], []).
Result:
 F (Peano) : s^120(0)
 F (int)   : 120

Reason why
----------
We run the meta-interpreter via a fixed family of predicates:
  holds1  for goal lists (mi/2-level),
  holds2  for atomic goals Fun('p', args),
  holds3  for (predicate-name, argument-list) pairs.

  1. holds2(factorial(s(N), F)) ⇒ [factorial(N, F1), prod(s(N), F1, F)]
  2. holds2(mi([G|Gs], [])) ⇒ [mi(Goals, [])] where Goals = body(G) ++ Gs
  3. holds2(mi([G|Gs], [])) ⇒ [mi(Goals, [])] where Goals = body(G) ++ Gs
  4. holds2(factorial(s(N), F)) ⇒ [factorial(N, F1), prod(s(N), F1, F)]
  5. holds2(mi([G|Gs], [])) ⇒ [mi(Goals, [])] where Goals = body(G) ++ Gs
  6. holds2(mi([G|Gs], [])) ⇒ [mi(Goals, [])] where Goals = body(G) ++ Gs
  7. holds2(factorial(s(N), F)) ⇒ [factorial(N, F1), prod(s(N), F1, F)]
  8. holds2(mi([G|Gs], [])) ⇒ [mi(Goals, [])] where Goals = body(G) ++ Gs
  9. holds2(mi([G|Gs], [])) ⇒ [mi(Goals, [])] where Goals = body(G) ++ Gs
 10. holds2(factorial(s(N), F)) ⇒ [factorial(N, F1), prod(s(N), F1, F)]
 11. holds2(mi([G|Gs], [])) ⇒ [mi(Goals, [])] where Goals = body(G) ++ Gs
 12. holds2(mi([G|Gs], [])) ⇒ [mi(Goals, [])] where Goals = body(G) ++ Gs
 … 963 more rewrite steps …

Rules used (in the order they are matched inside holds2):
  mi([], []).
  mi([G|Gs], []) → mi(Goals, []) via expansion of G.
  factorial(0, s(0)).
  factorial(s(N), F) → factorial(N, F1), prod(s(N), F1, F).
  prod(0, _, 0).
  prod(s(N), M, P) → prod(N, M, K), sum(K, M, P).
  sum(0, M, M).
  sum(s(N), M, s(K)) → sum(N, M, K).

This yields factorial(5) by repeated unfolding into `prod` and `sum` over Peano numbers.

Check (harness)
----------------
PASS 1: factorial(0) via meta-interpreter is 1.
PASS 2: factorial(1) via meta-interpreter is 1.
PASS 3: factorial(3) via meta-interpreter is 6.
PASS 4: factorial(5) via meta-interpreter is 120.
PASS 5: meta-interpreter is deterministic for factorial(5) (same result, non-empty traces).
PASS 6: number of rewrite steps grows with n (2 < 4 < 5).
