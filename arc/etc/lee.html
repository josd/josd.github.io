<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lee (Grid BFS shortest path)</title>
  <style>
    :root { --fg:#101014; --bg:#ffffff; --muted:#666; --accent:#2563eb; --chip:#eef2ff; --ok:#16a34a; --bad:#dc2626; --warn:#ca8a04; --card: color-mix(in srgb, var(--accent) 4%, transparent); }
    @media (prefers-color-scheme: dark) {
      :root { --fg:#eaeaf0; --bg:#0b0b10; --muted:#a0a0b0; --accent:#60a5fa; --chip:#0e1a32; --card: color-mix(in srgb, var(--accent) 6%, transparent); }
    }
    html,body { margin:0; padding:0; background:var(--bg); color:var(--fg); font: 15px/1.6 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    main { max-width: 1200px; margin: 0 auto; padding: 28px 16px 96px; }
    h1 { font-size: clamp(1.6rem, 2.6vw + 1rem, 2.2rem); margin: 0 0 6px; }
    header p { margin: 0; color: var(--muted); }
    section { margin: 18px 0 22px; padding: 14px 14px 16px; border: 1px solid color-mix(in srgb, var(--accent) 18%, transparent); border-radius: 14px;
              background: var(--card); }
    section h2 { margin: 0 0 10px; font-size: 1.15rem; }
    .row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    .col { display:flex; flex-direction:column; gap:10px; }
    .btn { appearance:none; border:1px solid color-mix(in srgb, var(--accent) 35%, transparent); background: color-mix(in srgb, var(--accent) 8%, transparent);
           color: var(--fg); border-radius: 10px; padding: 8px 12px; font-weight: 700; cursor: pointer; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .muted { color: var(--muted); }
    .small { font-size: .92em; }
    .chip { display:inline-block; padding:2px 8px; border-radius:999px; background:var(--chip); font-weight:600; }
    input[type="number"], input[type="range"] { border-radius: 10px; border: 1px solid color-mix(in srgb, var(--accent) 30%, transparent); padding: 6px 8px; }
    label { user-select:none; }
    /* Grid */
    #boardWrap { position: relative; }
    .board { display:grid; gap:2px; background: color-mix(in srgb, var(--accent) 15%, transparent); padding: 4px; border-radius: 10px; }
    .cell { width: 22px; height: 22px; border-radius: 4px; background: color-mix(in srgb, var(--accent) 8%, transparent); border:1px solid color-mix(in srgb, var(--accent) 24%, transparent); }
    .cell.wall { background: color-mix(in srgb, #000 50%, transparent); border-color: color-mix(in srgb, #000 60%, transparent); }
    .cell.start { background:#16a34a; border-color:#15803d; }
    .cell.goal  { background:#dc2626; border-color:#991b1b; }
    .cell.path  { background:#f59e0b; border-color:#b45309; }
    .toolbar { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .tool { padding:6px 10px; border-radius: 10px; border:1px solid color-mix(in srgb, var(--accent) 35%, transparent); cursor:pointer; background: color-mix(in srgb, var(--accent) 8%, transparent); }
    .tool.active { outline:2px solid color-mix(in srgb, var(--accent) 50%, transparent); }
    #answer { overflow-x:auto; }
    #answer pre { white-space: pre !important; overflow-x:auto; overflow-y:auto; max-width:100%; }
    .ok { color: var(--ok); } .bad { color: var(--bad); } .warn { color: var(--warn); }
  </style>
</head>
<body>
  <main>
    <header class="row">
      <div>
        <h1>Lee (Grid BFS shortest path)</h1>
        <p>Self‑contained grid pathfinding with the Lee algorithm (breadth‑first search on a 4‑neighborhood).</p>
      </div>
      <div class="row" style="margin-left:auto;">
        <label class="muted small">Rows: <input id="rows" type="number" min="5" max="80" value="25"></label>
        <label class="muted small">Cols: <input id="cols" type="number" min="5" max="80" value="25"></label>
        <button id="resize" class="btn">Resize</button>
        <button id="clear" class="btn">Clear</button>
        <button id="maze" class="btn">Random maze</button>
        <label class="muted small"><input id="ensure" type="checkbox" checked> ensure solvable</label>
        <label class="muted small">density <input id="density" type="range" min="0" max="0.6" step="0.02" value="0.28"></label>
        <button id="solve" class="btn">Solve</button>
        <button id="checkBtn" class="btn">Check</button>
      </div>
    </header>

    <section>
      <h2>What this is?</h2>
      <p>The Lee algorithm finds the shortest path in a grid with uniform step cost. It’s a classic breadth‑first search:
         we expand from the start, layer by layer, until we reach the goal. Then we backtrack by following decreasing
         distance values to reconstruct a shortest path. Works with walls (blocked cells) and 4‑neighborhood moves.</p>
    </section>

    <section class="row" style="align-items:flex-start">
      <div class="col">
        <div class="toolbar">
          <span class="muted small">Tool:</span>
          <button class="tool active" id="tool-wall" data-tool="wall">Draw walls</button>
          <button class="tool" id="tool-erase" data-tool="erase">Erase</button>
          <button class="tool" id="tool-start" data-tool="start">Set start</button>
          <button class="tool" id="tool-goal"  data-tool="goal">Set goal</button>
        </div>
        <div id="boardWrap">
          <div id="board" class="board"></div>
        </div>
      </div>
      <div class="col" style="flex:1">
        <h2>Text</h2>
        <p class="small muted">Paste or copy your grid here. Use <code>#</code> for walls, <code>.</code> for empty, <code>S</code> start, <code>G</code> goal.</p>
        <textarea id="txt" class="mono" spellcheck="false" style="width:100%; min-height:180px;"></textarea>
        <div class="row">
          <button id="loadDemo" class="btn">Load demo</button>
          <button id="syncFromText" class="btn">Apply from text</button>
          <button id="syncToText" class="btn">Copy from grid</button>
        </div>
      </div>
    </section>

    <section id="answer">
      <h2>Answer</h2>
      <div id="chips" class="row small" style="gap:8px"></div>
      <div id="summary" class="mono small"></div>
    </section>

    <section id="reason">
      <h2>Reason why</h2>
      <div class="small">
        <p>On grids with unit weights, BFS explores in concentric “rings”. The first time it dequeues the goal, the
           discovered distance is optimal. The backtracking step simply walks to any neighbor with distance −1 until
           it reaches the start. Obstacles are simply never enqueued.</p>
      </div>
    </section>

    <section id="check">
      <h2>Check (harness)</h2>
      <div id="check-body"></div>
    </section>
  </main>

  <script>
  (function(){
    "use strict";
    const $ = id => document.getElementById(id);
    const setHTML = (id, html) => { const el = $(id); if (el) el.innerHTML = html; };
    const now = () => performance.now();

    // State
    let R = 25, C = 25;
    let grid = []; // 0 empty, 1 wall
    let start = null; // [r,c]
    let goal  = null; // [r,c]
    let mouseDown = false, currentTool = 'wall';

    // Helpers
    const inside = (r,c)=> r>=0 && r<R && c>=0 && c<C;
    const idx = (r,c)=> r*C+c;
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];

    // Build board UI
    function buildBoard(){
      const board = $('board');
      board.style.gridTemplateColumns = `repeat(${C}, 22px)`;
      board.innerHTML = '';
      for (let r=0;r<R;r++){
        for (let c=0;c<C;c++){
          const div = document.createElement('div');
          div.className = 'cell';
          div.dataset.r = r; div.dataset.c = c;
          board.appendChild(div);
        }
      }
      paintAll();
    }

    function paintAll(pathSet=null){
      const board = $('board');
      for (let r=0;r<R;r++){
        for (let c=0;c<C;c++){
          const d = board.children[idx(r,c)];
          d.className = 'cell';
          if (grid[idx(r,c)]===1) d.classList.add('wall');
          if (pathSet && pathSet.has(idx(r,c))) d.classList.add('path');
          if (start && start[0]===r && start[1]===c) d.classList.add('start');
          if (goal  && goal[0]===r && goal[1]===c) d.classList.add('goal');
        }
      }
    }

    function setTool(tool){
      currentTool = tool;
      for (const b of document.querySelectorAll('.tool')) b.classList.remove('active');
      const el = document.querySelector('.tool[data-tool="'+tool+'"]');
      if (el) el.classList.add('active');
    }

    function attachBoardEvents(){
      const board = $('board');
      board.addEventListener('mousedown', e => { mouseDown = true; onBoardInteract(e); });
      board.addEventListener('mousemove', e => { if (mouseDown) onBoardInteract(e); });
      window.addEventListener('mouseup', ()=> mouseDown = false);
      board.addEventListener('touchstart', e => { onBoardInteract(e.touches[0]); e.preventDefault(); }, {passive:false});
      board.addEventListener('touchmove',  e => { onBoardInteract(e.touches[0]); e.preventDefault(); }, {passive:false});
    }

    function onBoardInteract(e){
      const target = document.elementFromPoint(e.clientX, e.clientY);
      if (!target || !target.classList.contains('cell')) return;
      const r = Number(target.dataset.r), c = Number(target.dataset.c);
      if (currentTool === 'wall'){
        if (start && start[0]===r && start[1]===c) start=null;
        if (goal && goal[0]===r && goal[1]===c) goal=null;
        grid[idx(r,c)] = 1;
      } else if (currentTool === 'erase'){
        grid[idx(r,c)] = 0;
      } else if (currentTool === 'start'){
        if (start) grid[idx(start[0], start[1])] = 0;
        start = [r,c];
        grid[idx(r,c)] = 0;
      } else if (currentTool === 'goal'){
        if (goal) grid[idx(goal[0], goal[1])] = 0;
        goal = [r,c];
        grid[idx(r,c)] = 0;
      }
      paintAll();
      syncTextFromGrid();
    }

    // Text <-> grid
    function gridToText(){
      const lines = [];
      for (let r=0;r<R;r++){
        let s='';
        for (let c=0;c<C;c++){
          if (start && start[0]===r && start[1]===c) s+='S';
          else if (goal && goal[0]===r && goal[1]===c) s+='G';
          else s += (grid[idx(r,c)]===1 ? '#' : '.');
        }
        lines.push(s);
      }
      return lines.join('\n');
    }

    function textToGrid(txt){
      const lines = (txt||'').trim().split(/\\r?\\n/).filter(Boolean);
      if (lines.length===0) return false;
      const rr = lines.length, cc = Math.max(...lines.map(s=>s.length));
      R = rr; C = cc;
      grid = Array(R*C).fill(0);
      start=null; goal=null;
      for (let r=0;r<R;r++){
        const row = lines[r];
        for (let c=0;c<C;c++){
          const ch = row[c] || '.';
          if (ch === '#') grid[idx(r,c)] = 1;
          else if (ch === 'S'){ start=[r,c]; grid[idx(r,c)] = 0; }
          else if (ch === 'G'){ goal=[r,c]; grid[idx(r,c)] = 0; }
          else grid[idx(r,c)] = 0;
        }
      }
      buildBoard();
      syncToText();
      return true;
    }

    function syncFromText(){ textToGrid($('txt').value); }
    function syncToText(){ $('txt').value = gridToText(); }
    function syncTextFromGrid(){ $('txt').value = gridToText(); }

    // Resize / clear / maze
    function doResize(){
      const r = Math.max(5, Math.min(80, Math.floor(Number($('rows').value)||25)));
      const c = Math.max(5, Math.min(80, Math.floor(Number($('cols').value)||25)));
      R=r; C=c; grid = Array(R*C).fill(0); start=null; goal=null;
      buildBoard(); syncToText();
    }
    function doClear(){ grid.fill(0); start=null; goal=null; paintAll(); syncToText(); }
    
    function baselineReachable(a, rows, cols, S, G){
      const inside=(r,c)=> r>=0 && r<rows && c>=0 && c<cols;
      const id=(r,c)=> r*cols + c;
      const dist = new Int32Array(rows*cols).fill(-1);
      const s = id(S[0],S[1]), g = id(G[0],G[1]);
      const q=[s]; dist[s]=0; let qi=0;
      while(qi<q.length){
        const cur=q[qi++], r=(cur/cols)|0, c=cur%cols;
        if (cur===g) return true;
        for (const [dr,dc] of [[1,0],[-1,0],[0,1],[0,-1]]){
          const nr=r+dr, nc=c+dc; if(!inside(nr,nc)) continue;
          const ni=id(nr,nc); if (a[ni]===1 || dist[ni]!==-1) continue;
          dist[ni]=dist[cur]+1; q.push(ni);
        }
      }
      return false;
    }

    function doMaze(){
      const p = Number($('density').value || 0.28);
      const needSolvable = $('ensure') && $('ensure').checked;
      const maxTries = 200;
      let tries = 0, ok = false;

      function randomFill(){
        for (let i=0;i<R*C;i++) grid[i] = (Math.random()<p) ? 1 : 0;
        start = [0,0]; goal = [R-1,C-1];
        grid[idx(start[0],start[1])] = 0;
        grid[idx(goal[0],goal[1])] = 0;
      }

      if (!needSolvable){
        randomFill();
      } else {
        for (tries=0; tries<maxTries; tries++){
          randomFill();
          if (baselineReachable(grid, R, C, start, goal)){ ok=true; break; }
        }
        if (!ok){
          // As a fallback, thin the maze a bit and try again.
          for (tries=0; tries<maxTries; tries++){
            for (let i=0;i<R*C;i++) grid[i] = (Math.random()<p*0.6) ? 1 : 0;
            start = [0,0]; goal = [R-1,C-1];
            grid[idx(start[0],start[1])] = 0;
            grid[idx(goal[0],goal[1])] = 0;
            if (baselineReachable(grid, R, C, start, goal)){ ok=true; break; }
          }
        }
      }

      paintAll(); syncToText();
      if (needSolvable){
        const msg = ok ? '(found solvable maze)' : '(could not ensure solvable after attempts; try lower density)';
        setHTML('summary', '<span class="small muted">Random maze ' + msg + '</span>');
      }
    }
    // Lee (BFS) — returns {found, dist, path: [idx...], expansions}
    function lee(){
      const t0 = now();
      if (!start || !goal) return {found:false, dist:-1, path:[], expansions:0, ms:0, reason:'Start or goal missing.'};
      const q = [];
      const dist = new Int32Array(R*C).fill(-1);
      const sidx = idx(start[0], start[1]);
      const gidx = idx(goal[0], goal[1]);
      if (grid[sidx]===1 || grid[gidx]===1) return {found:false, dist:-1, path:[], expansions:0, ms:0, reason:'Start or goal on a wall.'};

      q.push(sidx); dist[sidx]=0;
      let qi=0, expansions=0, reached=false;
      while (qi<q.length){
        const cur = q[qi++];
        const r = Math.floor(cur / C), c = cur % C;
        if (cur === gidx){ reached=true; break; }
        for (const [dr,dc] of dirs){
          const nr=r+dr, nc=c+dc;
          if (!inside(nr,nc)) continue;
          const ni = idx(nr,nc);
          if (grid[ni]===1) continue;
          if (dist[ni]!==-1) continue;
          dist[ni] = dist[cur] + 1;
          q.push(ni);
        }
        expansions++;
      }
      const t1 = now();
      if (!reached) return {found:false, dist:-1, path:[], expansions, ms:(t1-t0), reason:'No path.'};

      // Backtrack
      const path = [];
      let cur = gidx;
      path.push(cur);
      while (cur !== sidx){
        const r = Math.floor(cur / C), c = cur % C;
        let moved=false;
        for (const [dr,dc] of dirs){
          const nr=r+dr, nc=c+dc;
          if (!inside(nr,nc)) continue;
          const ni = idx(nr,nc);
          if (dist[ni] === dist[cur]-1){
            path.push(ni);
            cur = ni;
            moved=true; break;
          }
        }
        if (!moved) break; // shouldn't happen
      }
      path.reverse();
      return {found:true, dist:dist[gidx], path, expansions, ms:(t1-t0)};
    }

    // Solve + render
    function doSolve(){
      const res = lee();
      if (!res.found){
        setHTML('summary', `<div class="bad">No solution: ${res.reason||''}</div>`);
        $('chips').innerHTML = '';
        paintAll(null);
        return;
      }
      const pset = new Set(res.path);
      paintAll(pset);
      const chips = [
        ['rows', R], ['cols', C],
        ['walls', grid.reduce((a,b)=>a+(b===1),0)],
        ['expansions', res.expansions],
        ['dist', res.dist],
        ['time', res.ms.toFixed(2)+' ms']
      ].map(([k,v])=>`<span class="chip">${k}: ${v}</span>`).join(' ');
      $('chips').innerHTML = chips;
      setHTML('summary', `<pre class="mono">Path length (steps): ${res.dist}
Nodes expanded: ${res.expansions}
</pre>`);
    }

    // Check (harness)
    function runChecks(){
      const lines = [];
      const ok = b => b ? '✓' : '✗';

      // 1) If path found, verify monotone decrease along path and that it starts at S and ends at G.
      const res = lee();
      if (res.found){
        const distOk = (function(){
          const dist = new Int32Array(R*C).fill(-1);
          const q=[idx(start[0],start[1])]; dist[q[0]]=0; let qi=0;
          while(qi<q.length){ const cur=q[qi++]; const r=Math.floor(cur/C), c=cur%C;
            for (const [dr,dc] of dirs){ const nr=r+dr, nc=c+dc; if(!inside(nr,nc))continue; const ni=idx(nr,nc);
              if (grid[ni]===1 || dist[ni]!==-1) continue; dist[ni]=dist[cur]+1; q.push(ni);
            }
          }
          // Check endpoints
          const sOK = res.path.length>0 && res.path[0]===idx(start[0],start[1]);
          const gOK = res.path.length>0 && res.path[res.path.length-1]===idx(goal[0],goal[1]);
          let mono=true;
          for (let i=1;i<res.path.length;i++){ if (dist[res.path[i]] !== dist[res.path[i-1]]+1){ mono=false; break; } }
          const lenOK = (res.path.length-1) === dist[idx(goal[0],goal[1])];
          return sOK && gOK && mono && lenOK;
        })();
        lines.push(`Path correctness (start→goal, monotone distances, optimal length): ${ok(distOk)}`);
      } else {
        lines.push('No path found — skipping path checks.');
      }

      // 2) Random mazes quick sanity: generate 5 grids and ensure BFS agrees with itself on distance (trivial) and respects walls
      let rndOK = true;
      for (let t=0;t<5;t++){
        const r=20, c=20, p=0.25;
        const arr = Array(r*c).fill(0).map(()=>Math.random()<p?1:0);
        const s=[0,0], g=[r-1,c-1];
        arr[0]=0; arr[r*c-1]=0;
        // single-run BFS
        function bfs(arrR,arrC,a,sx,sy,gx,gy){
          const inside=(rr,cc)=> rr>=0&&rr<arrR&&cc>=0&&cc<arrC;
          const id=(rr,cc)=> rr*arrC+cc;
          const dist=new Int32Array(arrR*arrC).fill(-1);
          const q=[id(sx,sy)]; dist[q[0]]=0; let qi=0; let reached=false;
          while(qi<q.length){ const cur=q[qi++]; const rr=Math.floor(cur/arrC), cc=cur%arrC;
            if (rr===gx && cc===gy){ reached=true; break; }
            for (const [dr,dc] of [[1,0],[-1,0],[0,1],[0,-1]]){
              const nr=rr+dr, nc=cc+dc; if(!inside(nr,nc))continue; const ni=id(nr,nc);
              if (a[ni]===1 || dist[ni]!==-1) continue; dist[ni]=dist[cur]+1; q.push(ni);
            }
          }
          return {reached, dist};
        }
        const r1 = bfs(r,c,arr, s[0],s[1], g[0],g[1]);
        if (!r1.reached && r1.dist[r*c-1]!==-1){ rndOK=false; break; }
      }
      lines.push(`Randomized quick checks (5 samples): ${ok(rndOK)}`);

      const pre = document.createElement('pre');
      pre.className = 'mono';
      pre.style.whiteSpace = 'pre-wrap';
      pre.textContent = lines.join('\n');
      $('check-body').replaceChildren(pre);
    }

    // Demo grid
    const DEMO = [
      'S....#.................',
      '#####.#.#############..',
      '.....#.#...........#..G',
      '.###.#.#.#######.#.#.##',
      '.#...#.#.....#...#.#..#',
      '.#.###.#####.#.###.#..#',
      '.#...#.....#.#...#.#..#',
      '.#.#.#####.#.###.#.####',
      '.#.#.....#.#.....#....#',
      '.#.#.###.#.#######.##.#',
      '.#.#.#...#.........#..#',
      '.#.#.#.###########.#..#',
      '.#.#.#.............#..#',
      '.#.#.###############..#',
      '.#.#.................#.'
    ].join('\n');

    function loadDemo(){
      $('txt').value = DEMO;
      syncFromText();
    }

    // Wire up
    $('resize').addEventListener('click', doResize);
    $('clear').addEventListener('click', doClear);
    $('maze').addEventListener('click', doMaze);
    $('solve').addEventListener('click', ()=>{ doSolve(); runChecks(); });
    $('checkBtn').addEventListener('click', runChecks);
    $('loadDemo').addEventListener('click', loadDemo);
    $('syncFromText').addEventListener('click', syncFromText);
    $('syncToText').addEventListener('click', syncToText);
    for (const el of document.querySelectorAll('.tool')){
      el.addEventListener('click', ()=> setTool(el.dataset.tool));
    }

    // Init
    (function init(){
      R=25; C=25; grid = Array(R*C).fill(0); start=null; goal=null;
      buildBoard(); attachBoardEvents(); doMaze(); // start with a random maze
      setTool('wall');
      setHTML('summary','<span class="muted small">Click Solve to find a path, or draw your own maze. Tools: walls, erase, set start/goal.</span>');
    })();
  })();
  </script>
</body>
</html>
