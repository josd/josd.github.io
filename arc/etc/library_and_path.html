<!DOCTYPE html>
<html lang='en'>
<head>
  <meta charset='utf-8' />
  <meta name='viewport' content='width=device-width, initial-scale=1' />
  <title>The Library & The Path</title>
  <style>
    :root{ --bg:#ffffff; --ink:#111827; --muted:#6b7280; --accent:#2563eb; --ok:#16a34a; --warn:#d97706; --bad:#dc2626; --border:#e5e7eb; --surface:#f8fafc; }
    html,body{ margin:0; padding:0; background:var(--bg); color:var(--ink); font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Inter,sans-serif; }
    .wrap{ max-width:900px; margin:28px auto 80px; padding:0 18px; }
    h1{ font-size:28px; margin:0 0 6px; }
    p.lead{ color:var(--muted); margin:6px 0 18px; }
    .section{ background:#fff; border:1px solid var(--border); border-radius:14px; padding:16px; box-shadow:0 6px 20px rgba(0,0,0,.06); margin:14px 0; }
    label{ display:block; margin:10px 0 4px; color:var(--muted); font-size:13px; }
    input[type='number'], select{ width:100%; background:#fff; color:var(--ink); border:1px solid var(--border); border-radius:10px; padding:10px; }
    .row{ display:flex; gap:12px; flex-wrap:wrap; }
    .col{ flex:1 1 220px; }
    .btn{ background:var(--accent); color:#fff; border:0; padding:10px 14px; border-radius:10px; font-weight:600; cursor:pointer; transition:opacity .15s ease, filter .15s ease; }
    .btn:disabled, .btn.busy{ opacity:.6; cursor:not-allowed; filter:grayscale(1) brightness(.95); }
    .btn.busy::after{ content:''; width:14px; height:14px; border:2px solid rgba(255,255,255,.6); border-top-color:#fff; border-radius:50%; display:inline-block; margin-left:8px; vertical-align:-2px; animation:spin .9s linear infinite; }
    @keyframes spin{ to{ transform:rotate(360deg) } }
    .kpi{ display:flex; gap:12px; flex-wrap:wrap; margin-top:10px; }
    .kpi .item{ background:var(--surface); border:1px solid var(--border); border-radius:10px; padding:8px 10px; min-width:160px; }
    .kpi b{ display:block; font-size:18px; margin-bottom:2px; color:#111; }
    pre{ background:var(--surface); color:#111827; border:1px solid var(--border); border-radius:12px; padding:12px; white-space:pre-wrap; overflow-wrap:anywhere; word-break:break-word; max-height:50vh; overflow:auto; }
    details{ border:1px solid var(--border); border-radius:12px; padding:10px 12px; background:#fff; }
    summary{ cursor:pointer; font-weight:700; }
    .ok{ color:var(--ok) } .warn{ color:var(--warn) } .bad{ color:var(--bad) }
    .log{ font-size:12px; color:var(--muted); margin-top:6px; }
    .prose p{ margin:8px 0; } .prose ul{ margin:8px 0 8px 1.1rem; } .prose li{ margin:4px 0; }
    .muted{ color:var(--muted); }
    /* Let Answer & Reason cards expand; no inner vertical scrollbars */
    #answer, #reason,
    .answer, .reason,
    [data-card="answer"], [data-card="reason"] {
      height: auto !important;
      max-height: none !important;
      overflow-y: visible !important;
    }
  </style>
</head>
<body>
  <div class='wrap'>
    <header class='section'>
      <h1>The Library & the Path</h1>
      <p class='lead'>Answer → Reason → Check. Stabilize laws (the library), watch features emerge (the path), then verify. Everything runs in your browser. See also <a href="https://github.com/josd/josd.github.io/blob/master/the-library-and-the-path.md">The Library & the Path - Observership and the Infinite Game of Mathematics</a></p>
      <div class='prose'>
        <p><strong>What this is.</strong> A small, self-contained exploration of emergence. We toggle simple <em>laws</em> (e.g., gravity-stable, chemistry-stable, communication-stable, population-dynamics) and watch which <em>features</em> appear—stars, galaxies, carbon chemistry, life, mind, language, many minds, and culture. The narrative follows the P3 pattern: <em>Answer → Reason → Check</em>.</p>
        <p><strong>Why these choices.</strong> They illustrate a plausible dependency ladder: gravity enables large-scale structure; atomic and chemical stability enable carbon chemistry; stars and chemistry support life; from life we get mind; <em>language</em> sits between mind and culture; with population dynamics and many minds, <em>culture</em> stabilizes. These are schematic, not doctrinal: edit them to match your preferred story.</p>
        <p><strong>How it works.</strong></p>
        <ul>
          <li><b>Library.</b> The available stabilizations (laws) you can switch on.</li>
          <li><b>Path.</b> A sequence of steps “stabilize LAW”. As steps accumulate, dependencies fire and new features appear.</li>
          <li><b>Goal.</b> We ask for a particular observation set—here including <em>life, mind, language, many-minds, culture</em> (plus galaxies and carbon chemistry).</li>
          <li><b>Search.</b> Breadth‑first enumeration up to a depth limit. <em>Thorough</em> explores different orderings and keeps going after success; <em>Fast</em> dedupes by state and stops at the first success.</li>
          <li><b>Selection.</b> From all consistent endpoints we pick the shortest path; ties are broken deterministically by action strings.</li>
          <li><b>Checks.</b> Independent validations: recompute closure; confirm the observation set; monotone growth along the path; minimality of laws and steps; acyclic feature graph; and permutation‑invariance spot checks.</li>
        </ul>
        <p><strong>How to use.</strong> Choose a mode, tune <em>Max Depth</em> and <em>Cap Paths</em>, optionally add <em>Permutation Trials</em>, then click <em>Run</em>. The status row shows search scale; the three boxes list the chosen answer, a short reasoning narrative, and the check report.</p>
        <p><strong>What to expect.</strong> In this setup, a typical minimal path stabilizes atoms → chemistry (unlocking carbon chemistry), gravity (unlocking galaxies, stars, and—given other pieces—life and mind), communication (enabling language with mind), then population dynamics (yielding many minds and culture).</p>
        <p><strong>What this is not.</strong> Not a scientific claim or full simulation. Dependencies are illustrative and deliberately compact. Modify the <em>PR</em> map and <em>OBS</em> set in the code to try your own hypotheses.</p>
        <p class='muted'><em>Determinism.</em> With the same settings you’ll get the same selected path; only the search order changes when you change mode or parameters.</p>
      </div>
    </header>

    <section class='section' id='controls'>
      <h2>Controls</h2>
      <div class='row'>
        <div class='col'>
          <label for='mode'>Mode</label>
          <select id='mode'>
            <option value='thorough' selected>Thorough (order-distinct, expand after success, all laws)</option>
            <option value='fast'>Fast (dedupe by state, stop after success, only needed laws)</option>
          </select>
        </div>
        <div class='col'>
          <label for='maxDepth'>Max Depth</label>
          <input id='maxDepth' type='number' min='0' max='20' value='6' />
        </div>
        <div class='col'>
          <label for='capPaths'>Cap Paths</label>
          <input id='capPaths' type='number' min='1000' step='1000' value='120000' />
        </div>
        <div class='col'>
          <label for='permTrials'>Permutation Trials (in Check)</label>
          <input id='permTrials' type='number' min='0' max='10' value='1' />
        </div>
      </div>
      <div class='row' style='align-items:flex-end; margin-top:8px'>
        <button id='runBtn' class='btn'>Run</button>
        <span id='note' class='warn' style='margin-left:8px'></span>
      </div>
      <div class='kpi'>
        <div class='item'><b id='kEnumerated'>-</b><span>Enumerated nodes</span></div>
        <div class='item'><b id='kConsistent'>-</b><span>Consistent endpoints</span></div>
        <div class='item'><b id='kTime'>-</b><span>Total time (ms)</span></div>
        <div class='item'><b id='kMode'>-</b><span>Mode</span></div>\n      </div>
      <details style='margin-top:12px'>
        <summary>Show laws, features, observations</summary>
        <div id='dataDump' style='margin-top:10px'></div>
      </details>
      <div id='log' class='log'></div>
    </section>

    <section class='section'>
      <h2>Answer</h2>
      <pre id='answer'></pre>
    </section>

    <section class='section'>
      <h2>Reason</h2>
      <pre id='reason'></pre>
    </section>

    <section class='section'>
      <h2>Check</h2>
      <pre id='check'></pre>
    </section>
  </div>

<script>
window.addEventListener('DOMContentLoaded', function(){
  const logEl = document.getElementById('log');
  const log = (m) => { try { console.log(m); if(logEl){ logEl.textContent = String(m); } } catch(e){} };

  window.addEventListener('error', function(ev){
    if(document.getElementById('note')){
      document.getElementById('note').textContent = 'Script error: ' + ev.message;
      document.getElementById('note').className = 'bad';
    }
    log('Error: ' + ev.message);
  });

  try {
    // Data
    const LAWS = [
      'gravity-stable','atoms-stable','chemistry-stable','electroweak-stable',
      'inflationary-dynamics','magnetism-stable','communication-stable','population-dynamics'
    ];
    const PR = {
      // Cosmic structure from gravity
      'stars': new Set(['gravity-stable']),
      'galaxies': new Set(['gravity-stable']),

      // Chemistry stack
      'carbon-chemistry': new Set(['atoms-stable', 'chemistry-stable']),

      // Emergence ladder
      'life': new Set(['stars', 'carbon-chemistry']),
      'mind': new Set(['life']),
      'language': new Set(['mind', 'communication-stable']),
      'many-minds': new Set(['mind', 'population-dynamics']),
      'culture': new Set(['language', 'many-minds']),

      // Legacy continuity
      'observers': new Set(['mind'])
    };

    const OBS = new Set([
      'galaxies',
      'carbon-chemistry',
      'life',
      'mind',
      'language',
      'many-minds',
      'culture'
    ]);

    // Helpers
    const cloneSet = s => new Set(s);
    const union = (a,b)=>{ const r=new Set(a); for(const x of b) r.add(x); return r; };
    const subset = (small,big)=>{ for(const x of small) if(!big.has(x)) return false; return true; };
    const toKey = s => Array.from(s).sort().join('|');
    const shuffle = arr => { for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } };

    function inferFeatures(laws){
      if(!inferFeatures.cache) inferFeatures.cache = new Map();
      const k = toKey(laws); if(inferFeatures.cache.has(k)) return new Set(inferFeatures.cache.get(k));
      const feats = new Set(); let changed = true;
      while(changed){ changed=false; for(const [f,reqs] of Object.entries(PR)){
        if(!feats.has(f)){ const u=union(laws,feats); if(subset(reqs,u)){ feats.add(f); changed=true; } }
      }}
      inferFeatures.cache.set(k,new Set(feats)); return new Set(feats);
    }

    function neededLaws(){
      const need = new Set(); const stack = Array.from(OBS); const seen=new Set();
      while(stack.length){ const x=stack.pop(); if(seen.has(x)) continue; seen.add(x);
        const reqs=PR[x]; if(!reqs) continue; for(const r of reqs){ if(PR[r]) stack.push(r); else need.add(r); }
      }
      return need;
    }

    function expand(laws, allowed){
      const nxt=[]; const sorted=Array.from(allowed).sort();
      for(const ax of sorted){ if(!laws.has(ax)){ const ns=cloneSet(laws); ns.add(ax); nxt.push([ax,ns]); } }
      return nxt;
    }

    function enumeratePaths(opts){
      const maxDepth = opts.maxDepth, capPaths = opts.capPaths, thorough = opts.thorough;
      inferFeatures.cache = new Map();

      const useAll = thorough ? true : false;
      const needed = neededLaws();
      const allowed = useAll ? new Set(LAWS) : (needed.size ? needed : new Set(LAWS));
      const dedupe = thorough ? null : new Set([toKey(new Set())]);
      const stopAfterSuccess = thorough ? false : true;

      const initial = [new Set(), []]; // [lawsSet, steps]
      const queue = [initial];

      const paths = []; let enumerated = 0;

      while(queue.length){
        const [lawSet, steps] = queue.shift();
        const feats = inferFeatures(lawSet);
        enumerated++;
        paths.push({ path: steps, final_laws: new Set(lawSet), final_features: feats });

        const success = subset(OBS, feats);
        if(stopAfterSuccess && success) continue;
        if(steps.length >= maxDepth) continue;

        for(const [ax, newSet] of expand(lawSet, allowed)){
          const newFeats = inferFeatures(newSet);
          const delta = Array.from(newFeats).filter(c => !feats.has(c)).sort();
          const newStep = { action: 'stabilize ' + ax, added_law: ax, enabled_features: delta };
          const child = [newSet, steps.concat([newStep])];
          if(dedupe){ const k = toKey(newSet); if(dedupe.has(k)) continue; dedupe.add(k); }
          queue.push(child);
        }
        if(paths.length >= capPaths) break;
      }
      return { paths: paths, enumerated: enumerated };
    }

    function filterConsistent(paths){ return paths.filter(p=>subset(OBS,p.final_features)); }
    function choosePath(cands){
      if(!cands.length) return null;
      return cands.sort((a,b)=>{
        const len = a.path.length - b.path.length;
        if(len!==0) return len;
        const aa = a.path.map(s=>s.action).join('||');
        const bb = b.path.map(s=>s.action).join('||');
        return aa.localeCompare(bb);
      })[0];
    }

    function explain(chosen,totalNodes,consistentCount,maxDepth){
      const lines=[];
      lines.push('Goal: find a path that yields the observations: '+Array.from(OBS).sort().join(', ')+'.');
      lines.push('Enumerated '+totalNodes+' candidate states/paths (depth <= '+maxDepth+').');
      lines.push('Top-down selection filtered these to '+consistentCount+' consistent endpoints.');
      lines.push('We chose the shortest path achieving the goal; ties broken lexicographically.');
      lines.push('Selected steps:');
      chosen.path.forEach((st,i)=>{ lines.push('  '+(i+1)+'. '+st.action+' -> newly enabled features: '+(st.enabled_features.length? st.enabled_features.join(', '):'-')); });
      lines.push('Final laws: '+Array.from(chosen.final_laws).sort().join(', ')+'.');
      lines.push('Final features: '+Array.from(chosen.final_features).sort().join(', ')+'.');
      return lines.join('\n');
    }

    function check(chosen, permTrials){
      const recomputed=inferFeatures(chosen.final_laws);
      const c1 = toKey(recomputed)===toKey(chosen.final_features);
      const c2 = subset(OBS,recomputed);

      let lawProg=new Set(); let prevFeatures=new Set();
      let monotonic=true; let enabledOK=true; let seen=new Set();
      for(const st of chosen.path){
        if(!st.added_law || seen.has(st.added_law)){ monotonic=false; break; }
        seen.add(st.added_law); lawProg.add(st.added_law);
        const now=inferFeatures(lawProg);
        for(const x of prevFeatures){ if(!now.has(x)){ monotonic=false; break; } }
        const delta=Array.from(now).filter(x=>!prevFeatures.has(x)).sort();
        if(delta.join('|')!==st.enabled_features.join('|')) enabledOK=false;
        prevFeatures=now;
      }

      const disp=[]; for(const ax of chosen.final_laws){ const alt=new Set(chosen.final_laws); alt.delete(ax); if(subset(OBS,inferFeatures(alt))) disp.push(ax); }
      const minimalLaws = disp.length===0;

      let shorter=[]; if(chosen.path.length>0){ const sp=enumeratePaths({maxDepth:chosen.path.length-1, capPaths:200000, thorough:true}); const consShort=filterConsistent(sp.paths); if(consShort.length){ shorter=consShort[0].path.map(s=>s.action); } }
      const minimalSteps = shorter.length===0;

      function hasCycle(){
        const graph={}; Object.keys(PR).forEach(k=>graph[k]=new Set());
        for(const [c,reqs] of Object.entries(PR)){ for(const r of reqs){ if(PR[r]) graph[c].add(r); } }
        const visited=new Set(); const stack=new Set();
        function dfs(u){ visited.add(u); stack.add(u); for(const v of graph[u]){ if(!visited.has(v) && dfs(v)) return true; if(stack.has(v)) return true; } stack.delete(u); return false; }
        for(const node of Object.keys(graph)){ if(!visited.has(node) && dfs(node)) return true; }
        return false;
      }
      const acyclic=!hasCycle();

      const baseLaws=toKey(chosen.final_laws); const baseLen=chosen.path.length; let mismatches=[];
      for(let i=0;i<permTrials;i++){
        const perm=LAWS.slice(); shuffle(perm); if(perm.join('|')===LAWS.join('|')) shuffle(perm);
        const saved=LAWS.slice(); LAWS.length=0; perm.forEach(x=>LAWS.push(x));
        const p2=enumeratePaths({maxDepth:6, capPaths:120000, thorough:true});
        const cons2=filterConsistent(p2.paths);
        LAWS.length=0; saved.forEach(x=>LAWS.push(x));
        if(!cons2.length){ mismatches.push({trial:i+1, issue:'no_path_under_permutation'}); }
        else{ const ch2=choosePath(cons2); const eqA=baseLaws===toKey(ch2.final_laws); const eqL=baseLen===ch2.path.length; if(!(eqA && eqL)) mismatches.push({trial:i+1, final_laws_equal:eqA, path_length_equal:eqL}); }
      }
      const permInv = mismatches.length===0;

      const passed = c1 && c2 && monotonic && enabledOK && minimalLaws && minimalSteps && acyclic && permInv;
      return {
        recomputed_features_match:c1, observations_satisfied:c2,
        monotonic_along_path:monotonic, enabled_records_consistent:enabledOK,
        law_minimality:minimalLaws, dispensable_laws:disp.sort(),
        minimal_steps:minimalSteps, shorter_path_example:shorter,
        acyclic_feature_dependencies:acyclic, permutation_invariant:permInv,
        permutation_mismatches:mismatches, passed
      };
    }

    // UI wiring
    const el = {
      mode:document.getElementById('mode'), maxDepth:document.getElementById('maxDepth'), capPaths:document.getElementById('capPaths'), permTrials:document.getElementById('permTrials'), runBtn:document.getElementById('runBtn'),
      answer:document.getElementById('answer'), reason:document.getElementById('reason'), check:document.getElementById('check'),
      kEnumerated:document.getElementById('kEnumerated'), kConsistent:document.getElementById('kConsistent'), kTime:document.getElementById('kTime'), kMode:document.getElementById('kMode'), note:document.getElementById('note'), dataDump:document.getElementById('dataDump')
    };
    if(!el.runBtn){ log('Run button not found'); return; }

    function dumpData(){
      const laws = '<b>Laws</b><br>' + LAWS.map(a=>'- '+a).join('<br>');
      const obs  = '<br><b>Target observations</b><br>' + Array.from(OBS).map(o=>'- '+o).join('<br>');
      const deps = '<br><b>Feature dependencies</b><br>' + Object.entries(PR).map(([k,v])=>' - <code>'+k+'</code> <- '+Array.from(v).join(', ')).join('<br>');
      el.dataDump.innerHTML = laws+obs+deps;
    }
    dumpData();

    el.runBtn.addEventListener('click',()=>{
      el.runBtn.disabled=true; el.runBtn.classList.add('busy'); el.runBtn.dataset.prev=el.runBtn.textContent; el.runBtn.textContent='Running...';
      el.note.textContent=''; el.answer.textContent=el.reason.textContent=el.check.textContent='';
      el.kEnumerated.textContent='...'; el.kConsistent.textContent='...'; el.kTime.textContent='...'; el.kMode.textContent=el.mode.value;

      const thorough = el.mode.value==='thorough';
      const maxDepth = parseInt(el.maxDepth.value,10)||6;
      const capPaths = parseInt(el.capPaths.value,10)||120000;
      const permTrials = parseInt(el.permTrials.value,10)||1;

      const finish=()=>{ el.runBtn.classList.remove('busy'); el.runBtn.textContent=el.runBtn.dataset.prev||'Run'; el.runBtn.disabled=false; };

      requestAnimationFrame(()=>{
        try{
          const t0=performance.now();
          const {paths,enumerated}=enumeratePaths({maxDepth,capPaths,thorough});
          const consistent=filterConsistent(paths);
          const chosen=choosePath(consistent);
          const t1=performance.now();

          el.kEnumerated.textContent=enumerated.toLocaleString();
          el.kConsistent.textContent=consistent.length.toLocaleString();
          el.kTime.textContent=Math.round(t1-t0).toLocaleString();

          if(!chosen){
            el.answer.textContent=JSON.stringify({selected_path:null, final_state:null}, null, 2);
            el.reason.textContent='No consistent path found under current depth and logic.';
            el.check.textContent=JSON.stringify({passed:false}, null, 2);
            el.note.textContent='Tip: try Max Depth = 6 and Cap Paths >= 28961 for thorough mode.';
            finish(); return;
          }

          const answer={ selected_path: chosen.path.map(s=>s.action), final_state:{ laws:Array.from(chosen.final_laws).sort(), features:Array.from(chosen.final_features).sort() } };
          el.answer.textContent=JSON.stringify(answer, null, 2);
          el.reason.textContent=explain(chosen,enumerated,consistent.length,maxDepth);

          const chk=check(chosen,permTrials);
          el.check.textContent=JSON.stringify(chk, null, 2);
          el.note.textContent = chk.passed ? 'All checks passed.' : 'Some checks failed. See details above.';
          el.note.className = chk.passed ? 'ok' : 'bad';
        } catch(err){
          el.note.textContent = 'Runtime error: ' + err.message;
          el.note.className = 'bad';
          log(err && err.stack ? err.stack : err);
        } finally {
          finish();
        }
      });
    });

    log('Ready.');
  } catch(e) {
    log('Init error: ' + e.message);
    if(document.getElementById('note')){
      document.getElementById('note').textContent = 'Init error: ' + e.message;
      document.getElementById('note').className = 'bad';
    }
  }
});
</script>
</body>
</html>
