<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Apollonian gasket — generated by Descartes’ theorem</title>
<style>
  :root{
    --bg:#f6f8fb; --ink:#0f172a; --sub:#334155; --line:#d5dbe7;
    --outer:#e8f0ff; --inner:#cfe1ff; --edge:#4f79c8;
    --ok:#059669; --bad:#dc2626;
  }
  html,body{margin:0;background:var(--bg);color:var(--ink);
            font-family:system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif}
  header{padding:18px 20px;border-bottom:1px solid var(--line)}
  h1{margin:0 0 6px;font-size:22px}
  h2{margin:18px 0 10px;font-size:17px}
  p,li,small{line-height:1.45}
  main{display:block;padding:18px 20px 40px}
  .card{background:#fff;border:1px solid var(--line);border-radius:12px;
        box-shadow:0 1px 0 rgba(15,23,42,.04);margin:0 0 18px}
  .card header{padding:12px 14px;border-bottom:1px solid var(--line);
               border-radius:12px 12px 0 0}
  .card section{padding:14px}
  .muted{color:var(--sub)}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  .ok{color:#059669} .bad{color:#dc2626}
  svg{max-width:50%;height:auto;display:block;margin:0 auto;} /* half width */
</style>
</head>
<body>
<header>
  <h1>Apollonian gasket — generated by Descartes’ theorem</h1>
</header>

<main>

  <!-- WHAT THIS IS -->
  <article class="card">
    <header><h2>What this is?</h2></header>
    <section>
      <p>
        An SVG drawing of an Apollonian gasket: infinitely many circles packed inside one big
        circle so that every circle is tangent to its neighbors. We start from one enclosing
        circle and three interior tangent circles. Every new circle is computed from any
        three mutually tangent circles using Descartes’ circle theorem with the complex
        center formula, so both radius and position are exact.
      </p>
    </section>
  </article>

  <!-- ANSWER -->
  <article class="card">
    <header><h2>Answer — drawing</h2></header>
    <section>
      <svg id="fig" viewBox="0 0 240 240" aria-label="Apollonian gasket generated by Descartes’ theorem">
        <defs>
          <pattern id="grid" width="10" height="10" patternUnits="userSpaceOnUse">
            <path d="M10 0H0V10" fill="none" stroke="#eef2f7"/>
          </pattern>
        </defs>
        <rect x="10" y="10" width="220" height="220" fill="url(#grid)" stroke="#c7d2e5"/>
        <g id="layer"></g>
      </svg>
    </section>
  </article>

  <!-- REASON -->
  <article class="card">
    <header><h2>Reason</h2></header>
    <section>
      <ol>
        <li>
          Use curvature (bend) <em>k</em> = ± 1/r (enclosing circle has negative curvature;
          interior circles have positive curvature). For four mutually tangent circles with curvatures
          k₁, k₂, k₃, k₄:
          <br><strong>(k₁ + k₂ + k₃ + k₄)² = 2 · (k₁² + k₂² + k₃² + k₄²)</strong>.
        </li>
        <li>
          Given three tangent circles with curvatures k₁, k₂, k₃ and complex centers z₁ = x₁ + i y₁,
          z₂ = x₂ + i y₂, z₃ = x₃ + i y₃, the two possible fourth circles are:
          <br><strong>k₄ = k₁ + k₂ + k₃ ± 2√(k₁k₂ + k₂k₃ + k₃k₁)</strong>
          <br><strong>z₄ = ( S ± 2√Q ) / k₄</strong>
          <br>with <strong>S = k₁z₁ + k₂z₂ + k₃z₃</strong> and
          <strong>Q = k₁k₂ z₁z₂ + k₂k₃ z₂z₃ + k₃k₁ z₃z₁</strong>.
          The same choice of ± is used in both formulas. Replacing one circle in a tangent quadruple by
          its “other” solution fills the curvilinear gap.
        </li>
        <li>
          We iterate this replacement throughout the figure and stop when a new circle would be
          too small to see.
        </li>
      </ol>
    </section>
  </article>

  <!-- CHECK -->
  <article class="card">
    <header><h2>Check</h2></header>
    <section>
      <ul id="checks" class="mono"></ul>
      <div id="numbers" class="mono" style="margin-top:8px;white-space:pre-wrap"></div>
      <small class="muted">
        We verify: containment, no overlaps, curvature–radius consistency and signs, no duplicates,
        each generated circle is tangent to its three parents, and both Descartes identities
        (curvature and complex-center) on many sampled quadruples.
      </small>
    </section>
  </article>

</main>

<script>
/* -------- Complex helpers -------- */
function C(re,im){return {re,im};}
function cadd(a,b){return {re:a.re+b.re, im:a.im+b.im};}
function csub(a,b){return {re:a.re-b.re, im:a.im-b.im};}
function cmul(a,b){return {re:a.re*b.re - a.im*b.im, im:a.re*b.im + a.im*b.re};}
function cscale(a,s){return {re:a.re*s, im:a.im*s};}
function csqrt(z){
  const r=Math.hypot(z.re,z.im);
  const u=Math.sqrt((r+z.re)/2);
  const v=(z.im>=0?1:-1)*Math.sqrt(Math.max(0,(r-z.re)/2));
  return {re:u, im:v};
}
function dist(a,b){return Math.hypot(a.x-b.x,a.y-b.y);}
function nearTangent(a,b,eps=1e-4){
  const d=dist(a,b), sum=a.r+b.r, diff=Math.abs(a.r-b.r);
  return Math.abs(d-sum)<eps || Math.abs(d-diff)<eps;
}

/* -------- Fourth circle from three (correct complex Descartes) -------- */
function fourthFromThree(c1,c2,c3,knownFourth){
  const k1=c1.k, k2=c2.k, k3=c3.k;
  const z1=C(c1.x,c1.y), z2=C(c2.x,c2.y), z3=C(c3.x,c3.y);

  const s=k1+k2+k3;
  const t=Math.sqrt(Math.max(0,k1*k2+k2*k3+k3*k1));
  const kPlus=s+2*t, kMinus=s-2*t;

  const S=cadd(cscale(z1,k1), cadd(cscale(z2,k2), cscale(z3,k3)));
  const Q=cadd(
            cscale(cmul(z1,z2), k1*k2),
          cadd(
            cscale(cmul(z2,z3), k2*k3),
            cscale(cmul(z3,z1), k3*k1)
          )
        );
  const T=csqrt(Q);
  const wPlus=cadd(S, cscale(T,2));
  const wMinus=csub(S, cscale(T,2));

  const zPlus=cscale(wPlus,1/kPlus);
  const zMinus=cscale(wMinus,1/kMinus);

  const candPlus ={k:kPlus,  x:zPlus.re,  y:zPlus.im,  r:1/Math.abs(kPlus)};
  const candMinus={k:kMinus, x:zMinus.re, y:zMinus.im, r:1/Math.abs(kMinus)};

  if(knownFourth){
    const score = c => Math.abs(c.k-knownFourth.k)+Math.hypot(c.x-knownFourth.x,c.y-knownFourth.y);
    return score(candPlus)>score(candMinus) ? candPlus : candMinus; // choose the other one
  }
  return candPlus.k>0 ? candPlus : candMinus;
}

/* -------- Build gasket -------- */
(function(){
  const layer=document.getElementById('layer');
  const checks=document.getElementById('checks');
  const numbers=document.getElementById('numbers');
  const ok=t=>`<li><span class="ok">OK</span> — ${t}</li>`;
  const bad=t=>`<li><span class="bad">FAIL</span> — ${t}</li>`;

  // Seed configuration (outer + three mutual tangencies)
  const cx=120, cy=120, R=100;
  const outer={id:'O', k:-1/R, x:cx, y:cy, r:R};
  const A={id:'A', k:1/(R/2), x:cx-(R-(R/2)), y:cy, r:R/2};
  const B={id:'B', k:1/(R/2), x:cx+(R-(R/2)), y:cy, r:R/2};
  const C={id:'C', k:1/(R/3), x:cx, y:cy-(R-(R/3)), r:R/3};

  const circles=[outer,A,B,C];
  const key=c=>`${c.k.toFixed(9)}|${c.x.toFixed(6)}|${c.y.toFixed(6)}`;
  const seen=new Set(circles.map(key));

  function draw(c){
    const e=document.createElementNS('http://www.w3.org/2000/svg','circle');
    e.setAttribute('cx',c.x); e.setAttribute('cy',c.y); e.setAttribute('r',c.r);
    e.setAttribute('fill', c.k<0 ? 'var(--outer)' : 'var(--inner)');
    e.setAttribute('stroke','var(--edge)'); e.setAttribute('stroke-width', c.k<0?2.5:1.3);
    layer.appendChild(e);
  }
  circles.forEach(draw);

  // BFS over tangent quadruples
  const quads=[[outer,A,B,C]];
  const genRecords=[]; // each: {child, bases:[b1,b2,b3]}
  const minR=2.2, maxCircles=220;

  for(let qi=0;qi<quads.length && circles.length<maxCircles;qi++){
    const [c0,c1,c2,c3]=quads[qi];
    const arr=[c0,c1,c2,c3];
    for(let rep=0;rep<4 && circles.length<maxCircles;rep++){
      const keep=[arr[(rep+1)%4],arr[(rep+2)%4],arr[(rep+3)%4]];
      const known=arr[rep];
      const cand=fourthFromThree(keep[0],keep[1],keep[2],known);
      if(cand.r>minR && !seen.has(key(cand))){
        const inside = dist(cand,outer) <= outer.r - cand.r + 1e-6;
        if(inside){
          circles.push(cand); seen.add(key(cand)); draw(cand);
          quads.push([cand, keep[0], keep[1], keep[2]]);
          genRecords.push({child:cand, bases:[...keep]});
        }
      }
    }
  }

  /* -------- Checks -------- */
  // 1) Containment
  let insideOK=true;
  for(const c of circles){ if(c===outer) continue;
    if(dist(c,outer) > outer.r - c.r + 1e-6){ insideOK=false; break; }
  }
  checks.insertAdjacentHTML('beforeend', insideOK?ok('All circles lie inside the enclosing circle')
                                                 :bad('Some circle is not contained in the outer circle'));

  // 2) No overlaps (tiny slack; tangency allowed)
  let overlaps=0;
  for(let i=0;i<circles.length;i++){
    for(let j=i+1;j<circles.length;j++){
      const a=circles[i], b=circles[j];
      const d=dist(a,b), sum=a.r+b.r, diff=Math.abs(a.r-b.r);
      if(d < sum - 1e-4 && d > diff + 1e-4) overlaps++;
    }
  }
  checks.insertAdjacentHTML('beforeend', overlaps===0?ok('No overlaps detected among circles')
                                                     :bad(`Overlaps detected: ${overlaps} pairs`));

  // 3) Curvature–radius consistency and signs
  let kOK=true, signOK=true;
  for(const c of circles){
    const kabs=Math.abs(c.k), rinv=1/Math.abs(c.r);
    if(Math.abs(kabs-rinv)>1e-9) kOK=false;
    if(c!==outer && !(c.k>0)) signOK=false;
    if(c===outer && !(c.k<0)) signOK=false;
  }
  checks.insertAdjacentHTML('beforeend', kOK?ok('For every circle, |k| = 1/r'):bad('Some circle violates |k| = 1/r'));
  checks.insertAdjacentHTML('beforeend', signOK?ok('Curvature signs are correct (outer negative, inner positive)')
                                               :bad('Curvature signs are inconsistent'));

  // 4) No duplicates
  let dups=0;
  for(let i=0;i<circles.length;i++){
    for(let j=i+1;j<circles.length;j++){
      const a=circles[i], b=circles[j];
      if(Math.hypot(a.x-b.x,a.y-b.y)<1e-6 && Math.abs(a.r-b.r)<1e-6 && Math.abs(a.k-b.k)<1e-9) dups++;
    }
  }
  checks.insertAdjacentHTML('beforeend', dups===0?ok('No duplicate circles'):bad(`Duplicate circles: ${dups} pairs`));

  // 5) Each generated circle is tangent to its three bases
  let allGenOK=true, badGen=0;
  for(const rec of genRecords){
    for(const b of rec.bases){
      if(!nearTangent(rec.child,b)) { allGenOK=false; badGen++; break; }
    }
  }
  checks.insertAdjacentHTML('beforeend', allGenOK?ok('Every generated circle is tangent to its three parents')
                                                 :bad(`Tangency failure for ${badGen} generated circles`));

  // 6) Descartes (curvatures) on many quadruples
  function descartesCurvOK(q){
    const ks=q.map(c=>c.k);
    const S=ks.reduce((a,b)=>a+b,0);
    const L=S*S, R=2*ks.reduce((a,b)=>a+b*b,0);
    return Math.abs(L-R)<1e-9;
  }
  const sampleCount=Math.min(60, quads.length);
  let curvPass=true; for(let i=0;i<sampleCount;i++) curvPass = curvPass && descartesCurvOK(quads[i]);
  checks.insertAdjacentHTML('beforeend', curvPass?ok(`Descartes curvature identity holds on ${sampleCount} samples`)
                                                 :bad('Curvature identity failed on some sample'));

  // 7) Complex Descartes (centers) on many quadruples
  function descartesComplexOK(q){
    // (Σ kᵢ zᵢ)² = 2 · Σ_{i<j} (kᵢ kⱼ zᵢ zⱼ)
    const ks=q.map(c=>c.k);
    const zs=q.map(c=>C(c.x,c.y));
    let S=C(0,0); for(let i=0;i<4;i++) S=cadd(S, cscale(zs[i], ks[i]));
    let left=cmul(S,S);

    let right=C(0,0);
    for(let i=0;i<4;i++) for(let j=i+1;j<4;j++){
      right=cadd(right, cscale(cmul(zs[i],zs[j]), ks[i]*ks[j]));
    }
    right=cscale(right,2);

    const err=Math.hypot(left.re-right.re, left.im-right.im);
    return err<1e-6;
  }
  let cxPass=true; for(let i=0;i<sampleCount;i++) cxPass = cxPass && descartesComplexOK(quads[i]);
  checks.insertAdjacentHTML('beforeend', cxPass?ok(`Complex-center identity holds on ${sampleCount} samples`)
                                               :bad('Complex-center identity failed on some sample'));

  numbers.textContent =
    `Circles drawn: ${circles.length}
Quadruples generated: ${quads.length}
Generated-circle records: ${genRecords.length}
Minimum radius drawn: ${minR}px`;
})();
</script>
</body>
</html>

